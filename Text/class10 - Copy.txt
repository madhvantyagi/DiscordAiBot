Okay, can everybody see the slide that says Relational Algebra? Yes. Yes. Great. Okay, let's get started. I hope everybody is having a happy Wednesday. I was walking around the city today. It's like 80 degrees outside, so it's unpleasant. Unexpected in October, but still nice. So the objective for today is to get back to normalization. I just want to begin the discussion about the topic Relational Algebra. Relational Algebra is the mathematical language which underlies the SQL that you're doing. For example, when you do searches, when you do joins, when you have tables, when you have columns, there's a mathematical language called Relational Algebra, along with Relational Calculus, which allows you to specify the process of joining and how that impacts speed. So we're going to touch upon that. There's going to be a lot of parallels to what you saw in SQL, which is the hands-on. Now we're just discussing some of the underlying theory behind it. And Relational Algebra allows us to also perform searches and also to organize our data. So we're going to be discussing some terminology today. And so it's going to take a couple of classes to discuss Relational Algebra, Relational Calculus, and we'll do this on and off in the next couple of weeks. So Relational Algebra, just to be clear, is a mathematical language. There is no software that you use, unlike SQL, which is hands-on. You can log on, you can type it, you can compile it, you can get errors, or it executes. Relational Algebra is like pencil, paper. So let's get started. We'll do some terminology here. So Relational Algebra organizes into several different types of operations that we can perform, and they should all be similar. You can do a selection, projection, Cartesian product, union, or set difference. There are many others, like functions, for example. So the selection operation sounds like what in SQL? Select. Select. So Cartesian product, which is the process of joining two relations, two objects, sounds like what in SQL? How do we join? Join. We have join, but the way we discussed it in class was that if I have two tables, what's the process of connecting the two tables? Select from then what? Where the primary key in one table is equal to the foreign key in another table. So that's a Cartesian product. So let's do some terminology. We're going to keep recycling this terminology, but just laying the foundation for this. So what we used to call a table in SQL is called a relation in Relational Algebra. And so we have the table, like over here, and then with the relation. So within the relation, we have many columns. In SQL, it's called a column. In Relational Algebra, it's called attributes. So an attribute called branch number, attribute branch street, attribute city, attribute called postal code. Within the whole relation, it's called, you know, this is all one relation called branch. The relation at the bottom here, this is a relation called staff. So the relation called branch has four attributes, branch, street, city, postal code. And each row in the relation is called a tuple, T-U-P-L-E. So just changing some terminology. And the primary key, let's say it's branch number, that's still the case. And the terminology foreign key, notice how we have one row for each branch number and branch. And then when we keep track of the staff, we want to say, well, which branch does each staff assigned? Notice how we have branch number next to the staff over here. But the domain of branch number is only those values with the primary key branch number and branch. Okay, so that's still the same. Okay. And some other terminology, the degree is a number of attributes. So the degree is four for branch. And the cardinality is a number of tuples. So in branch, it's five. One, two, three, four, five. So cardinality is the number of rows, the degree is the number of attributes. Okay, so we're going to keep making reference to this terminology. Okay, so let's say that here I have one relation. So how many attributes do I have in this relation? Six. Right, so I have title, rating, genre, director, data release, actor. So I have six attributes. And I have a total of one, two, three, four, five tuples, five rows. Okay, so let's say that I wanted to do a search. Find all movies that have a rating of PG-13. So I have to create a query where the attribute rating is equal to PG-13. This should sound familiar as what you had to do in SQL. So that's the concept of a selection in relational algebra. Okay, so selection, key takeaway is the selection is eliminating the rows. Okay, relational algebra does certain things. One of them is selection. Another thing that you can do in relational algebra is a projection. Projection is a process of how do you limit your attributes. I'm not interested in all my attributes. I only want to see some attributes. So in SQL, what's the equivalent of displaying only some attributes? I'm using a select statement, but basically picking certain columns over others. Correct. So in relational algebra, you'll say select title, comma, rating, comma, actors from my table. As compared to saying select star. You know, I'm used to just saying select star just as a matter of convenience. But if I wanted to limit my attributes or projection, I would say select and then what are the column names. Okay, so often you do both. Limit rows, find all movies rated PG-13, and then display in my output. Just display the title, rating, and actors. That's it. I can have 100 attributes about my shows, but I'm only displaying three. Selection and projection. Okay. Let's review Cartesian product. And you may remember this from your, like, discrete mathematics class. So let's say that I have a relation called P. And P has two tuples. Tuple A, tuple B. Let's say I have another relation called Q. And Q has, you know, three tuples. Tuple 1, tuple 2, tuple 3. Okay. So P, Cartesian product Q, which is a join, means I'm taking every row in P and joining it to every row in Q. And then repeat that. So A is going to be joined to 1. I'm just going to draw here. So A is going to be joined to 1. A is going to be joined to 2. A is going to be joined to 3. So that's where we get A1, A2, A3. And then we're going to say B is going to be joined to 1, B joined to 2, B joined to 3. So all possible permutations. B1, B2, B3. So when we say P, Cartesian product Q, that's taking every tuple in P, joining it to every tuple in Q. So the equivalent in SQL is, you know, select from table, comma, table, comma, table. You join multiple tables together. And this is necessary if you have to answer a question. But you need attributes from more than one relation. So we'll do examples of this. Okay, so let's do some syntax. Like what commands do we actually have to enter? What's the terminology in relation algebra? So we have two commands. One is the selection. So over here. So this is my selection. And we use this select symbol. Okay. And then we're saying, this select, from which relation do you want to do the search on? And then the predicate is, what is the search? Rating equal PG. So what is your expression? That evaluates to true or false for each tuple. Then you also have another symbol. So this is projection. I want to limit my attributes. Then from which relation? Relation called R. Replace R with the name of the relation. And then you list all the attributes you want to display. So attribute 1, attribute 2, attribute 3, et cetera. Okay. So we're going to be focusing on selection and projection. Almost all the questions you're going to be answering are going to involve both selection and projection. Okay. Let's skip that one. Okay. So let's do a quick example. Okay. So we're going to do some examples to illustrate this together. And then we're going to go, you know, hands-on. We're going to pencil and paper. We're going to design a database using relational algebra. Okay. So now let's do some examples. So we have a relation called customers, another relation called stores. So customers has how many tuples? Three. Right. So we have three tuples. And customers also has three attributes. So attribute, attribute, attribute. And this is my primary key. Okay. So one tuple for each customer. We also have a relation called store. My primary key, store street, store city, store zip. Okay. And the rules are, you know, try not to give – don't give spaces to your attribute names. And your attribute should be descriptive. Okay. So don't call the attribute XYZ. Call it, you know, city, state, zip. Make it – anybody who looks at it will understand. Okay. So I have two relations. Okay. I have two more relations, a relation called, you know, animals and a relation called purchases. Okay. So now we have these four relations, but they're, you know, they're – have similar attributes. Okay. So let's go back here. So I have customer, customer first, customer last. And relations to store is what is information about the store. Store, street, city, zip. Then I have the animals. So this is like a pet store that I'm designing here. Okay. So in my pet store, we also have to keep track of the animals. You know, each animal – so we have to keep track of the – excuse me. So we have to keep track of the species of the animal. We also have to gender and some type of number, whether it's an aggressive animal or not aggressive animal. And a pet store also sells, you know, animals and also sells, like, accessories, you know, like fish balls and fish food. So we have something called a product type to keep track of what is the product. And finally, we have purchases, which is last. Why is the purchases, like, my last relation? What's, like, special about my attributes here? Don't they draw from other tables? So you would need those other relations to – So customer ID is what type of attribute? Warranty? Well, customer ID is what type of attribute? Well, what is my domain? What is my list of allowable values for customer? Only what? Here's customers. Here's customer. So what's my domain of customers? Integers? Excuse me? Integers? Well, the integer will be the type of data, the column type. It's a number. That's true. But what's my domain? Domain is the list of allowable values. I can only enter which number is here. They must be from where? From the customer relations. So customer ID is what type of attribute? Primary key. Primary key. And my domain of customer ID and purchase is what? It could be a constraint, a rule that we discussed to, like, five classes. That allows you to limit the values here. This is a foreign key. So customer ID is a foreign key. And it's limited. My domain is I can only pick a value 100 if 100 exists as a primary key in the customer relation. And 407 has to exist in the customer relation. That ensures you of maintaining data integrity. And so this is a foreign key, which is why this relation is less, because I had to first create the customer relation before I made it as a foreign key here. Have an animal ID. Animal ID is what type of attribute? What is my domain of animal ID? A purchase could only be made for which animals? They have to be in the animals table. Correct. So what kind of attribute is this? Foreign key. Right. Notice I keep asking the same question. Okay. So this is my over here. So this is my foreign key. My domain is B902 here. It can only be from this selection. 903 here can only be from there. Okay. And finally, so it's like who, what, where, when. Who is making the purchase? What is being purchased? Where is it being purchased? So store ID. Store ID is what type of attribute? Also a foreign key. Correct. It draws from the store table relation. Right. So store ID is a foreign key, which means my domain can only be, it can only make a purchase, can only make a purchase if the store actually exists in the store relation, like five. That's it. Can't make a purchase from store number 27 because they have a foreign key in place and 27 doesn't exist. Okay. Maintaining dagger integrity. It's your responsibility to create these designs so you enforce these rules. Okay. Okay. Okay. So let's say that I want to join. I want to join two relations. I want to join customers and purchase. Let's say I want to answer the question, which customer, first name, last name, purchased what product? Okay. I have the customer relation. I have the purchase relation. Okay. So I want to do a Cartesian product. The Cartesian product is I use this. So this means take every tuple for every attribute in customers and take every tuple in purchases and then combine them. Okay. So I have my, this works better if I have like a blackboard, but bear with me here. So customer, notice how customer is 100 boldly. Okay. 100 boldly. And then the first tuple in my purchase is 100, 9025. That's the first tuple. So I'm taking the first tuple in purchase to the first tuple in customer. So 100 boldly is being combined with the first tuple in purchase. The first tuple in customers is being combined with the second tuple in purchase. Second tuple of purchase is 100, 9075. So it's 100, 9075. Then finally take the first tuple in customer and combining with the third tuple in purchase, 407, 9035. Okay. And then keep repeating this. Then take the second tuple that's in customer, Sally Smith, and take the third tuple that's in Jim Henson. Then take Sally, combine it with the first tuple in purchase, Sally with the second tuple in purchase, and Sally with the third tuple in purchase. Then take Jim and then with the first tuple in purchase, second tuple in third purchase. So this is what Cartesian product is. Take every tuple in customer, combine with every tuple in purchase. Notice how it also brings in all of the attributes. Okay. What's your evaluation of this? Once they complete this, a new relation is formed. So this means send the output to a new relation called A. So this is all now called relation A. What's your evaluation? What do you think about relation A? Any time anybody asks you, like, a computer question, what do you think about something, usually you can answer it, evaluate it in one of three ways, like, you know, speed, cost, reliability. That's how you can begin to make a decision. That's how you can begin to be answering most questions, computer questions for the rest of your life. People are going to ask you what do you recommend, what do you think, and usually the answer is formed in terms of speed, cost, and reliability. So what's your evaluation of this relation called A? What do you think, Andrew, Aviv, Sarah? So speed. Does speed really apply here? This is a mathematical language. What do you think? Okay. You have to participate. They're just not going to continue. You have to communicate. If you don't communicate, then, you know, I'm going to have to take a different approach, which you're not going to like. Okay? I mean, maybe I'm wrong, but I feel like here it doesn't seem like it would take too long, but if you have, like, a lot of data, I feel like it would take longer just because you're going through every single value of the table. Okay, so it takes time. But it's a mathematical language, so I'm not really evaluating it based upon CPU cycles or processor. So, you know, speed is, you know, however long it takes me to, you know, combine it. Okay. So what was the cost of implementing this? If I'm paying you, let's say, $300 an hour and your job is to do it and it takes you, like, two minutes to implement it, then it'll take, like, $3 to implement. Okay, big deal. Reliability. Speed, cost, reliability. What's another word for reliability in this context? Did you say, like... What's another word for reliability? Coherence, maybe? Don't make it complicated. Coherent. I don't know what that means. Like when the data is... I meant, like, data coherence, when the... So what I was thinking about is, like, when one table, when it's entered, when it's executed, when the data is... I meant, like, data coherence, when the... So what I was thinking about is, like, when one table, when it's entered, it could be possible that it's not entered yet in the other table, like the... All the values here exist in my existing relations. Like, you know, it's not like it's not going to be entered. It's what the current state. So another word for reliability is, is it accurate, right? Something reliable, is it accurate? Speak for us for reliability. Is this accurate? No, not really. Because I'm just applying values. So the stuff that's highlighted is not accurate. So unless you put in a statement to remove it, those purchases never happened. Which purchases never happened? The ones that were highlighted, the... Okay, so what's special about this? Well, let's go back to the original data. Who made a purchase? I'm looking at my original data. Who made a purchase? Which customers? Customer 100 and customer 407. Right. Customer 100 and customer 407 made a purchase. It's clear. It was done. They purchased this animal at this store. Done. Remember, 100, 407 made a purchase. If we did the Cartesian products here, which customers made a purchase? Well, according to the table, the relation, it says 100. 100. And then it also says 302 and then 407. Okay, so according to this, so 100, 407. So here we have... So 100 made a purchase. That's true. 302 didn't make a purchase. Like, this makes no sense. Then 407 made a purchase. So 407 is there. Why is 407 there three times? How many purchases did 407 make? Only one. One. 407. What did 407 purchase? What exactly did 407 purchase? Animal. Which animal? For all the animals in the store, which animal? 903. 903. 407 purchased 903. So according to this, 407 purchased what? 407 purchased 902. 907, 903. Okay, that's false. Doesn't make any sense, right? Okay, 907 here purchased, you know, 407 purchased 903. But here, like, you know, this one is right, 903. But like, that's wrong. That's wrong. That just didn't happen. Okay, what did 100 purchase? 902 and 907. 100, 902, and 907. But back here, you know, 100, you know, purchased 902. Like, that's good. 100 purchased 907. That's good. And it says here 100 purchased 903. Like, that's stupid. That's wrong. Then we have this, like, Sally. Sally's 302. Did Sally purchase anything here? No. That's nothing. So Sally didn't purchase anything. So, like, you know, so they, you know, this is wrong. This is wrong. This is wrong. But then this guy Jim, like, 407. But we decided he didn't purchase 902 and 907. So all these items in yellow, like, were never purchased. Just wrong. When I say reliability, I ask you what you think about it. The first word out of your mouth when your manager asks you is, like, it's wrong. Like, don't make it complicated. Why is it wrong? Now that you know it's wrong, the next question is why? Well, it's not producing the right output in terms of the purchases. We're seeing more data than is actually accurate. Right. Why? I guess because of the implementation method, the Cartesian products. Right. So we combined every tuple and customer, and we combined every tuple and purchase. But every customer did not make a purchase. Some customers made a purchase. Some customers were just looking around the store, you know, smiling at the fish. That's it. Okay. So, but which, by looking at this, this relation called A, what's the pattern? How do we know which are the wrong values? The rows in yellow. What's the message of identifying the rows in yellow? They're wrong. Never happened. I think it's multiple by three. Like, each of them has, like, three transactions you're showing. No, that's true. There were three customers with three purchases. That's why I have nine rows. Nine times three is nine. That's true. But, like, what's about the rows in yellow? Rows in yellow are just wrong. Purchases never happen. So what's special? What's the pattern? Anytime something is… Customer ID. Yeah, yeah, yeah. Sorry. I was just going to say the customer ID isn't equal. So customers.customerID and purchase.customerID for all the yellow instances are not equal. Okay. So you have where the customer… But this customer is from the customers table. This customer is from the purchase table. Because both customer and purchases both have the customer ID. It's the way of linking. That's the way of joining them together. And notice how when customer ID, 100, equals 100. Oh, that's good. 100 equals 100. That's good. It's a legitimate transaction. But notice how 100 here doesn't equal customer ID here. It's 407. Make it different. So give me a search where I want just the rows in white, but I don't want the rows in yellow. Don't worry about the syntax. Just give me a search. Where I find the rows in white, but not include the rows in yellow. Create an expression, a search that will be true, that will evaluate the true. You could select all the attributes and then use a where clause where customers.customerID is equal to purchase.customerID. Correct. I want to display those rows, meaning in white, where the customer ID and the customer's relation is equal to the customer ID and the purchase relation. I don't care about the rows in yellow. I only want those where they match. So this is called, these rows in yellow are called disjoint rows, meaning it's a total mess, it's junk. So you want to prevent these disjoint rows from occurring. So okay, so you do a selection, and you say only join those where customer ID and customer is equal to customer ID and purchase, or where primary key is equal to the foreign key value. So then, okay, so let's do a, so I just wrote it out like this way here. So here I have customer here, I have purchase here, and this is what you said. I did a select, which is to limit my tuples, and then this is my predicate. This is my search. Only display those tuples where the customer ID and customer is equal to the customer ID and purchase, where the customer ID and customer is equal to the customer ID and purchase. 100 here is equal to 100, and 407 is equal to this. So these are the white rows that we had in the previous table. I did, am I, so in this expression, am I limiting my tuples or limiting the attributes? The tuples. Right, I'm limiting the tuples. Okay, so all the attributes and customers and all the attributes and purchases are being displayed. Okay, that could sometimes be a little bit unwieldy. Like, for example, at the university. That would take a Cartesian product of students and then Cartesian product that to registration. I mean, students have like, I don't know, 100 attributes. First, middle, last, address, city, state, zip, high school, SAT scores, phone numbers, e-mails, guardians, passwords, you know, financial aid, you have a lot of attributes about you. And you have immunizations, you have financial aid. So sometimes I don't want all those attributes. So you could also limit that if you want to. Okay, so let's go through. I like having rules. You know, my whole life is rules and computers. So we, you know, just follow the steps. So there's no thinking involved. We just follow the steps. Okay, so how do we answer relational algebra questions? So, you know, step number one is whenever you get a question, you know, identify all pets that were sold. Display the customer name and the pet. Okay, find out what relations you need in order to answer this question. Where do you have to search? Then you need to find out, well, I don't need all the attributes to answer this question. If I need first name and last name, then those are the attributes I need. Okay, so find all the relations you need to answer the question. Find all the attributes. And also find out what you need in your output. What's going to be displayed? More attributes. Okay, then if you have more than one relation, similar to SQL, then what's your common attribute? How do you join two together? What's your primary key? What's your primary key? Okay, so once you follow these steps, then you'll be able to answer the questions. Okay, so let's do some examples. Okay, so let's analyze this. Again, we'll do some, you know, that I pre-prepared, and we'll also do some directly when we, you know, start writing our own relational algebra. So in the first question, identify animals purchased on this date. Display, this means my output. Display the customer name and the animal purchased. Okay, so I'm just going to, you know, like rewrite, you know, let's rewrite this question and just give it colors. So this part is the date. This part is the name. And this part is what animals purchased. Okay, so how do we do the yellow? I just need to find out what relation, what attribute. Where is the animals purchased? Where is that stored? I'm just going back to here. Where is the animals? Where do we keep track of the animals that were purchased? Purchase table? Right, the purchase table. Okay. Okay, so we have the purchase table. And then we have a column called data purchase. Okay. Then we say display the customer name. So based upon my design, where do we track the names of my customers? Customer's table. Customer's relation. Forget table. We're using relation. So customer relation, customer first, customer last. Those are my attributes. Okay. And then to notice over here, so customer's relation, customer first, customer last. I'm just gathering together. I'm just finding all the relations, finding all the attributes. Where is everything located to answer my question? Finally, I want, like, the output. Like, what was actually purchased? Okay. So I want to know, like, what is the, you know, the animal. So we have a relation called, you know, animal. And then we say since, you know, since we didn't give these animals names, you know, like Dory or Nemo or anything like that, or like Rover, so I need to send something. So how about I say species. You know, this is what was actually purchased. Okay. So in the animals, you know, relation, I want this as my output. Okay. You see three relations. You see purchase, customer, animal. First word that comes to mind is what? Uh-oh. This is a job for what? Select. Okay. You have to get the attributes and create one big relation that has all of these attributes. Okay. So if you have more than one relation, it sounds like a job for what? Join. You have to join. So the name in relational algebra for joining is what? Cartesian product. Right. Cartesian product, like X over there. Okay. You know, do a, I want to say purchase. So purchase, Cartesian product, you know, customer. Cartesian product, like animal. Okay. Okay. So how do I join these together if I have a common attribute? Okay. Okay. So let's analyze this. Again, we'll spend, you know, time going through each step. We'll have to see what it looks like when it's all done. Okay. So the first step is, I'm not a big fan of joining all three all at the same time. You know, I don't think it's a good idea to do customers, Cartesian product purchase, Cartesian product animals. That's just like too complicated for the brain. So keep it simple. Customer and purchase. What do customer and purchase have in common? What's the common attribute? Customer ID. Right, because customer ID is in purchase, customer ID is in purchases over here. So in purchase, customer ID is here, and right in purchase, ID is over there. Okay. Okay. So customer ID is here, customer ID is here. I want to remove destroyed rows. Only find those tuples where customer ID in purchase is equal to customer ID in purchase. Okay. Save this answer to a relation called A. Think of A like a temporary relation, a placeholder. Okay. And then selection is to do my, you know, limit my tuples. Let's not forget about animals. There's three relations. So animals needs to be joined with what? You know, like with A from above here. Okay. So A includes which attributes are in A? Which attributes are in A? Customer. Animal ID. Well, every attribute in customer and every attribute in purchase, right? So A includes every attribute in customer, every attribute in purchase. But I only want, so what's the common attributes in A? And in animals, what's the common attribute? Animal ID. Right. So purchase, remember, purchase has, see, purchase has animal ID. Okay. And purchase has animal ID. And also, you know, obviously animals also has animal ID. So combine A with animals, Cartesian product. Remove disjoint rows. This is my predicate. Do a selection to limit my tuples. Save the results to B. Okay. So B is the important relation now because B includes A. Okay. So it's step-by-step, line one, line two. But going back to the original question, the original question was what? Purchased on this date, 1-5-2019. I have to further limit my tuples. Okay. I have to do another search where date of purchase is equal to this. That's my search. And I want to limit, I want to perform the search on relation B. That came from, like, up here. Relation B. Why did I add in this? Because there might be some, I think there are some instances where you could have, like, an item, so, like, a fish bowl or something. So you just want to make sure you don't make any cuts. Right. So go back to the original question. That's true. That's why when your manager gives you, like, create a report, do a search. You have to listen very carefully as to what the request was. So I say display the customer name and animal purchase. Got it. I searched on the date. But why did I do that other search for animals? See? I want animals purchased. I'm not asking you about fish tanks, just animals. So remember on this original table we had, you know, we're selling fish bowls that are accessories and we're selling, you know, like a species like poodle and this. Okay. So I want to limit it where product, you know, type was equal to animal. Okay. And so I said over here, like, product type is equal to animal. And then save this output to this relation. This is a more descriptive relation. I called it animals 2019-105. No particular reason. Okay. Now, finally, go back to the original question. What's my output? I keep getting myself hung up here on which page I'm on here. What's my output in this question? What gets displayed on the screen? The animals purchased. Right. Display, customer name, animal purchase. That's my output. Okay. I don't want to have all the attributes in purchase, all the attributes in customers, all the attributes in animal. I just want to have selected attributes. Okay. So this is a job for, like, over here. So we know selection, limit by tuples. So now we're going to do projection. Projection limits my attributes. From the relation called animals this, only display the customer first, comma, customer last, comma, and species. Customer first, customer last, species. Save this to a new relation called answer. Answer. So a new relation is born called answer. Answer has how many attributes? Three. Right, three. So one, two, three. How many tuples? Two. Right. So two tuples, Bo. Why is Bo repeated twice? Because it's a different purchase. Right. So at 1-5-2019, just going back to my original data, 1-5-2019. So here it is over here. So 1-5-2019. See, Bo, you know, purchased 902 and 907. So what is a 902 and 907? So 902 is a poodle over here, and 907 is a shark. Poodle, shark. And then go back to the outputs, so poodle, shark. So this is the underlying, like, you know, concepts, theory, underneath all of your SQL that you're doing. Which I'm certain I'm doing. Okay. Let's do another question here. It's the same question. Okay. Let's do this one here. Okay. So let's do another question. Okay. Again, this only works if we do, like, a hundred relational algebras. You just have to do a lot of these in order to see the patterns so you get comfortable. Okay. So we're going to be doing a lot of these. So we're going to, like, you know, bang them to everybody's head. Okay. Identify the female animals purchased by this customer. We're limiting it. And my output is going to be display the species and the date of purchase. If you want to identify where do we get these attributes and what relations, what we're doing is following our rules. So in yellow, in order to find female animals and display the species, we have to look at the animal relation. And if you go back to the animal relation, notice how animal contains gender and species. Gender and species. Okay. And which one are we on? This one. Gender and species. Okay. And I also want to – how do I get information about this customer? Well, I have to search the customer's relation and look for customer first, customer last. Got it. And then date of purchase. That's what we did before. That's going to be the purchase relation. And DOP is the attribute. Okay. So we have animal customers purchased. I have to join all three. Animals customers purchased. Okay. So let's do one at a time. So I'm going to join, follow the same pattern as before. Take customer, join it with purchase. So I say customer, my common attribute between customer and purchase is customer ID. Save that out to A, using A selection. Then I want to, you know, join A from the previous statement and Cartesian product that to animals. Getting a little fancy here. So I'm not going to Cartesian product this to every tuple of animals. I'm going to do another select right here. I'm only limiting it to only those tuples that are – where this is true. And then removing disjoint rows here, save it to B. And I also had a requirement to limit it to females. And only for customer first is bow, and customer last is blade. Why is B here? We saved it in B before. Right. So we're taking the B from up here, then referencing it down there. Okay. And then finally, you know, C over here. This is the output of this line. So that feeds into that. And customer data purchase, because in the previous one, I just wanted my output to B, to play the species and the data purchase. That's my output. So projection limits my attributes. I don't want all the attributes. I just want some attributes. So species, data purchase, saving into a new relation called answer. So a new relation is created called answer with species, data purchase. And as one tuple pooled in, I'm going to save it to B. And I'm going to save it to B. So a new relation is created called answer with species, data purchase. And as one tuple pooled in the data. Okay. So this logic is, you know, do your limiting your tuples, and then further limit the tuples. And then at the end, in your output, make it look pretty, limit the attributes using projection. Okay. So let's do this. I'm going to switch over to my iPad. So together we're going to come up with a new design, a new relation. And we're going to do some relational algebra. Okay. So let me just switch over. Give me a second here. Where's my pencil? Professor, will relational algebra be on the exam? No. The answer is no. We're just starting this. So. Thank you. You're welcome. Okay. So I'm switching over. One second. Share. Okay. Do you all see my screen? Yes. Yes. Got it. Okay. So let's create a database. So give me an idea. You want to do the Netflix that we did before? Do relational algebra on that? Or you want to do something else? Yes, Netflix. Okay. So give me a relation that we're starting with. We're just converting our tables to relations. Give me a relation. Customers. Okay. So you have customers. So I'm going to write the attributes like this. So what are some attributes in customers? Give me the big ones, the main ones. Don't give me large ones. Customer ID. Okay. Customer first and last. And let's say credit card. Okay. Okay. So this is my relation. That's my relation. And these are my attributes. Attribute, attribute, attribute. Attribute, attribute. Okay. Actually, we did it with the email as the primary key for customers. Okay. Fair enough. I could even erase. How about that? Okay. Okay. Give me another relation. Actors, films. Okay. So give me some key attributes. I don't care about the small stuff. Give me the big ones. About the entity, about the human being, the person called an actor. What do we want to track about the actor? Keep it simple. Actor ID. Okay. Everything needs a primary key. So underline is going to be primary key. Okay. What else? Comma. Actor first and last name. I'm going to say gender. Okay. So I have a total of one, two, three, four. Okay. And give me a third relation. So you sit down in front of your computer and you want to watch something. Shows. Movies or shows. Okay. So you have shows. Remember, you can't watch it until you define what the shows are. So what about the show? Not the show, but just the show itself. So a television show, a movie. Genre. Yeah. So the genre, show ID, title. Okay. Star Wars. Science fiction. Show ID 100. Language. Give me something which is like, how do I know if it's a TV show or if it's a movie? Give me a way of tracking that. TV show or movie? Show type. So show type. Okay. So my domain of show type is, you know, M or TV. Okay. Now, finally, you know, at the end, how do we track which customer watched what show when? The viewing table. Relation. Right. Okay. Who is doing the viewing? Customer. Customer ID. Show ID and email. Right. Email. Email. So email. So who is doing the viewing? What is being viewed? What is being viewed? Who, what, where, when? What is being viewed? When is it being viewed? Hit the play button. It's streaming. When is it being viewed? View date. And just to be clear, date means month, day, year, hours, minutes, seconds. Okay. Okay. What's my primary key? What relations need a primary key? And email be the primary key. They can be more than one. Like one person could view more than one show on different days or the same day. So email can't be the primary key. Is show ID the primary key? No, because multiple people can watch the same show. Correct. So show ID is not the primary key. Correct. So show ID is not the primary key. How about view date? Is view date the primary key? Also no, because multiple people can view shows on the same day. Correct. Okay. So how about if we combine all three together? It's a composite primary key. Is that a legitimate composite primary key? Meaning is there a way that you can break that that doesn't follow the business requirements of Netflix? Is it possible for you to watch the same show more than once on the same date? Yes. Yeah. I watch it always. In the morning and in the afternoon I watch it again. And then I watch it again and I watch it again. Okay. So this can't be a primary key. So how do you want to spell that? What are the attributes here? Maybe a viewing or a view ID. Right. So we can't find an existing attribute. Then let's make one up. Don't make it complicated. Good. View ID, done. Okay. Okay. So let's answer some questions now. Okay. I'm not worried too much about the actual data. You know, like Star Wars, Harrison Ford, et cetera. Because, you know, this is a mathematical language. You can put data in, but, you know, for now let's not get worried about the data. Let's do a question. Okay. So question one. So I want to, you know, identify all customers. Display the customer name. Right. That's my question. So I need relational algebra to answer this. Okay. So let's take a look at this. So from which relations am I searching? Displaying the customer name. Customers. So my relation that I'm searching, table called customer. Okay. And within the customer's relation, which attribute do I need? Last name. Last name. Okay. Okay. So you got lucky on this one. It's one relation. Do you have to use a Cartesian product? No. No, because it's just one. Okay. I need to identify all customers. Am I limiting my customers, true or false? False. Right. I'm not limiting. I'm limiting all the customers. Okay. So there is no selection. This is my symbol for selection. I don't need a selection. I'm not limiting my tuples. Okay. I said all customers. But I only want to display as many attributes in customers. Email, first, last, credit card number. But I only want to display the customer name. So give me a command that limits my attributes. You know, three commands. Select customer first, customer last. Well, not select. Remember, select limits my tuples. But we're not limiting tuples. Projection. Right. So projection. Projection. Okay. So what I want to do is I do a projection from what relation? Customer. And which attributes do I want to display? What do I want to limit? Customer last name. And then finally, you have to send the output somewhere. Send the output to a relation. So the output goes to the relation that's called answer. There you go. So a new relation is born called answer. And the number of tuples will be, well, whatever number of tuples I had in customer. And it will just be two attributes. Customer first, customer last. Okay. So you're really deploying selection, projection, and Cartesian product. Those are the three operations. Okay. Generally speaking, to use selection first and then do a projection last. You know, sometimes, you know, there are other ways of doing it, but that's, you know, one approach. So question number two. Okay. So you give me a question that will involve two relations. What are your thoughts? Give me a question that will involve two relations. Maybe you will use Netflix and, you know, other streaming services. Give me a question. Yes, identify all customers who watched a, like, an action show. Okay. So identify customers who viewed an action show. What is your output? What do you want to display on the screen? Display the customer first name, last name, and the show title. Okay. So let's evaluate this. Okay. Identify customers who viewed an action show. Does that mean for the last 25 years that Netflix has been a business? Or do you want to limit that any further? Because right now, like, every customer on the planet Earth of Netflix for the last 25 years. I guess you could do, like, on a specific date. Okay. So, like, on 10-1-2-3. Okay. So, you know, either way is fine. You could certainly view every customer, you know, in the world, but you limit it to one day. Okay. Let's find the relations. Okay. So let's go through it here. So you say the word, you know, action shows. You also have it viewed on a certain date. You want to display all this as my output. Okay. You want to find action shows on a certain date and this. So where do these relations come from? So how about your output? Where does this come from? Customers. Right. So you have. Shows, customer, and view. Three tables. So you have customers. Okay. Customer first, customer last. And you also have show title. Where is show title stored? Shows. Okay. So you have, like, shows. So you have the relation called shows. And so that's this one, this one, this one. But then you said action shows. Where were action shows stored? View. So in view, where is action? They're also in shows. Right. So genre. Right. Genre. Okay. So shows now has genre. And we also had show title. Show title we have. Okay. And then, finally, the date. When do we keep track of when a show is viewed? In the view table. Right. So view right there. Now you have views. Oh, yeah, yeah. Okay. So you have three relations. Customer, shows, views. Okay. Now that you have three, first thing that comes to mind is how do I organize when I get three? I can only join if what's true. Join. And do a Cartesian product. So customers, Cartesian product, shows. I have to join them all together. Okay. Customer and shows. Is there any common attribute between customers and shows? No. No. Not directly. No. Okay. So, like, that stinks. Okay. So I can't join customers and shows. So customers and shows, I have to join them all together. Okay. That stinks. Okay. So I can't join customers and shows. So customers can be joined with what? You have to join with the view. View. Just going to, like, move this over a little bit here. Sorry. That's so cool. Okay. Okay. So customers and views. Okay. But I don't want every tuple and customer to be joined to every view. That's going to say, you know, I'm going to have disjoint rows. So how do I limit it? I don't want every customer, every tuple and customer joined to every tuple and views. I want to limit it. Selection. How do I remove disjoint rows? Every Cartesian product you do for the rest of your life, you have to remove disjoint rows. Okay. What's the common attribute between customer and views? So where customers go to the customer section. Show ID and view ID. Okay. So customers.email is equal to view.email. Notice how you have email there, email there. Okay. And let's say send this output to A. So we did customer and views. So that is A. And now can I join A to shows? What's the common attribute between A and shows? Remember, A is every attribute in customer and every attribute in views. So do we have a common attribute in views? ID. So we have customer and view. Hold on a second. So we have customer and view. So we have every attribute here, every attribute here. And we want to combine that with shows. And then shows is. So what does every attribute in views, every attribute in shows. I'm sorry, every attribute in customer and views. So you have show ID here. And then a new relation, show ID there. Okay. Okay. So then you want to say selection A.ID is equal to shows that. And then send this to B. I like doing it in like small little pieces. Don't try to make one long line. Okay. So now that we've got all of my attributes together in one relation, well B, how do I further limit it by date? Would you do a projection on B? Remember, I'm still limiting it. You only want to see only those tuples. So projection limits the attributes. I want to limit the tuples. So still doing selection. So give me a way of how do I find the view date? Where it's only going to be 10-1-2023. So view date right there. Okay. So how do I get view date? Give me an expression. Give me a predicate to find only 10-1-2023. View date equals 10-1-2023. So view date is equal to 10-1-23. There you go. Okay. And then send this output to let's say C. So did we finish all my searches? All my limiting on my tuples? So we did this. What's missing? The genre. Genre is missing. We're missing action shows. So where do we search for action shows? Where is that stored? In the show solutions. Right. So shows has genre. Okay. So I want to say genre is equal to action for the relation called B from the previous line. Okay. This predicate must be true. This predicate must be true. Both must be true. What's my operator? And. And. Okay. So terminology, that is equal to and. That is equal to or. That's it. So I'm going to use and over there. So this must be true on the left. This must be true on the right. Both predicates must evaluate to true. Only if both predicates on the left and right evaluate to true, then will I, you know, add that tuple to relation C. It's finally at the end. Display. My customer and show title. I want to limit my attribute. Sounds like a job for what? Projection. From what relation? From C. C. And my out will be. Customer first, customer last, and show title. And then send the out relation to. Okay. You can call these relations anything you want, you know, try to keep it descriptive. Okay. So we're fleshing out. We're building out our language of relational algebra, and we're going to be able to do all types of things. Find me all shows that would not use count up the number of shows. You know, what's the what's the highest rated show? What's the lowest rated show? So we have an underlying relational algebra to answer all of these questions. And all of this supports, you know, in my sequel, the underlying code for all this relational algebra. Okay. So read up on relational algebra and we'll discuss this bar. Okay. Let me. Stop the recording here. I do like my little iPad. That helpful to you. Yeah, that's good. Yeah. I like my handwriting. Is my handwriting great? Right here.
