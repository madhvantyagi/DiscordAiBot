Okay, let's get started. One final sound check. Anybody see my Word document and hear me okay? Yes. Great. Hope everybody is doing well today. Today's a Monday schedule at Queens College. So the objective for today is we're going to do a review of the exam and continue our discussion with relational algebra. Okay. So let's just, we have a busy schedule today. So we're going to discuss relational algebra and specifically within relational algebra we're going to be discussing functions and going to do the exam review and exam procedures. Okay. So just as a reminder, administrative items, we have an exam scheduled for tomorrow, Wednesday at eight o'clock. I was not able to coordinate with the college about getting a room. So the exam will be online using Blackboard and we'll discuss the exam procedures and how that works during the review session. Okay. So if you could stop me at like 10 minutes to nine and so we have enough time to go through the exam. Okay. Any other administrative items before we get started? Yes, no? Okay. So... I got one question. Yeah. Will foreign keys be on the exam? Yes. Language SQL will be on the exam, primary key, foreign keys, et cetera. Yeah. Okay. So... Okay. So let me just share my... I'm going to share my screen. Okay. So I just switched to my iPad. You all see this? Yeah. You all see this? Yes. Okay. Yes. Okay. So let's continue our discussion about relational algebra. So we have another process in relational algebra, which is a mathematical language, which allows us to perform aggregate information. This is equivalent to a function in SQL, okay? So let's say that we had a relation, and let's say this relation was our actors. So this is my relation, and then in the relation, you know, actors, we had a... Hold on, I'm just having technical issues here. Okay. So we have a function, so the SELECT, and if I would do SELECT of this relation, and we could use the function, we can use a function called COUNT. Let's say... So actor ID. So this is my predicate, my search, so this is my relation. This is the selection, and then we're going to send the output to A, so a new relation. And what COUNT will do is it will count the number of couples, the number of rows that are in the actor's relation. So for instance, if my actor's relation was this, so actor ID. So actor ID number 100, actor number 107, and 997. Okay, so we have a total of three couples, so then the COUNT with this, then the output of this will be a new relation is created, you know, correlation number A, correlation A, and relation A will have one couple as my output with the value of three, okay? So this function, COUNT, is known as an aggregate. It doesn't display all the couples in the table, it just performs some type of calculation. For example, this. Let's do another function. Another function will be, let's say we have a, we're doing a calculation, so we're doing this sum, okay? So let's say I have a, let's say I have a bank. The bank has a relation where they keep track of all the accounts. So we have a relation called ACCOUNT, ACCOUNT NUMBER, okay? So we have a, so COUNT NUMBER, so balance of $5,000, and owner ID is number 987. ACCOUNT NUMBER 1110114, balance of $6,000, owner ID number 999. How many tuples are in the ACCOUNT relation? Two, right, two tuples, okay? So if I were to do, so ask the question. So identify the number of accounts, so then display, display the number, okay? So, so selection, from what relation, what's the relation, ACCOUNT, ACCOUNT, okay? And I want to identify the number of accounts, so I want to count the number of tuples. So I say C-O-U-N-T, and then, you know, let's say I pick a, I pick a, a attribute that I know is going to have a value, so let's say A-C-T-N-U-M, and then send the output to answer. And then a new relation is going to be created, called answer, and then it's going to have the number of tuples, which will be two, so answer is a new relation, and has one tuple with one value. Let's say I were to change this. How can I modify the ACCOUNT table to keep track of whether or not the account is active or not active? What can I do to modify the, the structure of the ACCOUNT relation to determine if it's active or not active? What do you think? Can you repeat again? Excuse me? Can you repeat again the question? How can I modify the ACCOUNT relation to determine whether or not this account is active? How do I know that this account is active or this account is active? Give me a way of tracking that. Non-zero balance, maybe. Say it again? Non-zero balance. Okay, so you're saying if you have a balance greater than zero, that your account's active. Okay. Fair enough. So, let's say, let's make another row. So, nine, nine, seven, one, one, two, three, so balance of zero. And the owner ID is one, one, two. Okay. So, identify the number of, number of active accounts. So, give me a search to find the number of active accounts. Thomas, Sonny, Savantha, Nahim. So, let balance comma owner ID comma account number from account. Yeah, we're doing relational algebra. I'm doing SQL. Oh, okay. So, give me a search to find active accounts. So, give me a search. So, select from what relation? Active accounts. Okay. So, what rule did we say to determine whether or not an account was active or not? Balance is not equal to zero or greater than zero. So, balance greater than zero. So, this is my predicate. This is a search. This search will be evaluated for every row, every tuple, and will be evaluated to true or false. So, for the first tuple, is balance greater than zero, true or false? True. Okay. Then on the next one, is balance greater than zero, true. Third one, is balance greater than zero, true or false? False. False. Okay. So, then a new relation is created, let's say A. So, A will have how many tuples? Two. Right. Okay. So, A will have, you know, just those two tuples. That's it. Two whole tuples. Okay. Okay. But my answer was, my question was, like, display the number. I want the number two. Okay. Okay. Okay. So, then select count. From which relation am I searching now? A. Right. Okay. A. So, I'm mapping up the number of tuples there. And then send this to a new relation called answer. So, the answer will have the value two. Okay. What happens if balance is negative? Like an overdraft? Okay. So, it just evaluates over here. Is balance greater than zero? We just made that as our banking rule. So, if a balance is greater than zero, then the account is active. So, if the balance is negative, you know, how do you want to handle that in banking? What does a negative balance mean in banking? The customer owes money. Okay. So, maybe the accounts, maybe a negative balance still means the account is active. So, give me another way. If we can't rely upon balance to determine whether an account is active, give me another way. This is more of like a business requirement for banking. How about if you make another attribute? So, you can keep track of, like, when the account was opened and when the account was closed. So, let's say the account was open on 5-1-2000. Account was open on 5-2-2000 and then 6-1-1995. So, what does null mean? Account closed equal to null. What does that mean? It means it wasn't closed. Account is still open. Okay. So, null. But this was closed on 12-1-2015. So, based upon this new method of tracking the accounts, that we're not relying upon balance, because somebody could have a negative balance but still have an open account. So, give me a new search to find active accounts. Rather than balance is greater than zero, what's my search? Account closed equals null. Okay. We can say account closed equal to null. Then that would be an active account. Okay. Fair enough. Okay. So, I want to find out new question. How much money does this bank have on deposit? Okay. So, what type of calculation do I need to do? So, total on deposit. Sum. Excuse me? A sum. Sum of what? Balance. Okay. So, I can do a select from a relation called account. And a new function. Before, we did a function called count. Now, we're doing a function called sum. So, sum of balance. So, my balance is going to be like $11,000. So, a new relation is created called answer. There's one tuple called with a value of $11,000, which is sum of $5,000 and $6,000. So, sum is also useful. Okay. Okay. Let's say I want to identify, you know, like which branch. Let's say when people open up an account, they typically make an account like next to each, you know, in a certain branch. And also, we also keep track of, like, where the person, like, lives. So, let's say I want to identify, you know, balances by zip code. So, not balance. I want to say, better grammar here. I want to say total deposits by zip code. So, I want to know which neighborhood in Queens has the most, you know, which customers in Queens do I have the most balances. Okay. So, what's about tracking that? So, I want the output to look something like zip code. Let's say 11367. In the zip code 11367, the sum of all the deposits equals, let's say, 7,300,000. Zip code 11369 has a total deposit of, like, $400,000. And zip code of, like, 10019, let's say somewhere in Manhattan, deposits of, like, $50 million. Okay. So, I have two columns. So, this column is my zip over here. And then this is the sum of all the balances within that zip. Okay. So, right now we just have one relation. We have one relation called accounts. So, what is the more relations that we need in order to answer this question? The owner's address, city, state, step. Okay. So, we have a relation over here, you know, called owner. So, if I would just knew where the owner lived, 1414 Main Street, Flushing, New York, 11367, then I could figure out, you know, based upon the owner's address, and I know what the owner's balance is, I could figure out, I think I can get this type of output. Okay. So, give me another relation I need to create here. Is it balance? Well, I already have balance over here. I need to know where does the owner live. So, give me a new relation that needs to be created. Address. Excuse me? Address. Okay. So, describe this new relation that needs to be created. Street. Well, I have a column street, city, state, and zip code. Okay. So, I'm going to have street, city, state, zip. Okay. The account, sorry, and the owner ID. Okay. So, I'm just saying this owner, so owner ID 987. Why did I enter 987? Because the value exists in the domain of the account relation. Right. So, owner ID here, owner ID here. Okay. So, 1414. So, 1414 Main Street, Flushing, New York, 11367. I have another owner, 999. So, 902 Fifth Avenue, New York, New York. So, 10019. And then I have another owner, 112, and it's 902. Okay. So, I have how many tuples are in this new relation? Three. Three. And give me a new name for this relation. Is it an address? Well, how about we call owners? Okay. So, this relation is called owners. Each relation needs to have a primary key. What's my primary key? Owner ID. Okay. So, this is my primary key. And owner ID here is a foreign key. Because the owner ID in the account can only be from my domain of owner ID in owners. Okay. So, now that I have two relations, a relation called owners. Whoops. Relation called, whoops. Let's do that one again. So, I have a relation called owners and a relation called accounts. Now that I have two relations, what's the method of joining these two relations together? You know, three relation algebra commands. We can use where? No, this is relational algebra, not SQL. Projection. So, we have selection, which limits rows. We have projection, limits attributes. So, selection limits horizontal rows. Projection limits attributes, like vertical. What's the third operation that we know in relational algebra? What's that? The join. What's it called in relational algebra? Cartesian product. Okay. So, selection, projection, Cartesian product. So, I can only perform a join of two relations, account and owners, if what is true? If the account has balance? You can only do a join of two relations if what is true? If they have a common column? Correct. A common attribute. What's my common attribute between owners and accounts? Owner ID. Okay. So, we can do a... So, account, Cartesian product, owners. But I want to remove disjoint rows. So, my selection is what? I only want to join which rows in accounts to which rows in owners, where what is true? Where account.ownerID is equal to owners.ownerID? Correct. So, I can say account. Okay. So, go back up to here. So, I want to join this one and this one and then make that connection. Only join with that true statement. Okay. So, send this output to A. And then go back to the original question. So, I want to identify total deposits by zip code. I want the output to look like this. So, now A, A includes the two columns I need. It includes the column called zip code. I need that in my output. And it also has balance. Because A is a combination of account, all attributes in accounts and all attributes in owners. Okay. So, we actually have a slight, you know, change here. So, we have an aggregate function. We're going to use, like, that symbol. And we're going to say to the left of the symbol, we're going to say zip code. This is like doing subtotals, like in programming or in Excel. So, on the left side, I'm going to put my zip code, which matches up against this. And then the right side, give me a formula to get the second column. What function do I have to do here? Within each zip code, I need to do what function? Sum. So, I want to do a sum. Sum of which attribute? Balance. Okay. So, this is a new operation, which is like this symbol. This is called my aggregate function. The left side of the aggregate is my subtotals, which is the zip. So, I'm going to send each of the distinct zip values. It's going to sum up all the, you know, the balances. Sum all the balances. And then make one row for each distinct zip value. And then send the output to, let's say, a new relation. Let's say it calls, well, we already had A. Let's call it, like, B. So, then B will be, you know, this output that you see here. Okay. So, give me another question that we could, you know, generate from my banking database using functions that might involve more than one relation. Give me something, another search that you might need to do or you would like to do. Which accounts opened before the 2000s? Which account opens when? Before the 2000s. Which account opened before the year 2000? Yeah. Okay. And what's going to be your output? Only one account? Okay. So, where do I get this information? Open before 2000. Which relation is that from? Account. Okay. And I want to look at account open. Okay. So, I want to look at account. So, select. So, I can say A, C, T, O, P, E, N. So, it's, like, less than. So, I'll say 1, 1, 2000. From which relation? Okay. So, this is my credit kit. This is my search. Send this output to A. And then now if I were to do a count. Select count. So, this will display the number of rows, the number of tuples that are before this. Give me another question. So, Professor, is it possible to do, like, question number four, using one relation, like one select? Which one? Question four? Yeah. Or do you have to use two? Okay. So, the question is, I have one line and I have a second line. So, your question is, can it be combined into one line? Yeah. Absolutely. So, you could also rewrite this. You know, another way of rewriting it is you say or, is, so you just, you know, put it on one line. So, you just do, you know, select, A, C, T, open, less than, 1, 1, 2000. Then I want to, within all of this, then do a select. Then do a count. But count of all of this, everything on the inside. Okay. Because all of this, everything inside of here, is a new relation. So, it gets created. So, then I'm going to just, I'm going to be counting, you know, all of this on the outside. And then I just count here, say a count. Could do that. My preference is I think it's easier to do it in several lines, only because it's easier to debug. You have to make any corrections. Something like this, all in one line, like this, you know, it's a little bit more difficult to understand and to evaluate. I think it works better if you just, you know, evaluate in small little bite-sized chunks. You do a little bit in one, a little bit in two, a little bit in three, a little bit in four, and you combine it. And you build it up, build it up, build it up. But certainly you can do it in one long line. Okay, thank you. My approach is always, you know, make things easy. You know, reduce the complexity. Okay. We also have another function. So, question number five. So, identify the account with the highest balance. Okay. So you have a function called max, M-A-X. So, if I were to say, you know, select max balance from, this will return, you know, the highest balance. Okay. It will return, you know, the number, you know, like $5 million, whatever the highest balance is. Okay. So max, so the most popular functions are max, you know, count, sum, and average. Those are used a lot. Okay. And also, you could also do more than one function. Let's say that I wanted to know not just over here, not just how many total deposits there were by zip code, but I wanted a third column that actually showed the number of accounts. So, for example, it would be zip total deposits number. So, yes, 11367 has a large balance, but it also has, you know, 300,000, 350,000 accounts. And 10019 only has 10,000 accounts. And this has 5,000 accounts. So here you can determine a relationship with high balance, but a small number of accounts. Each account has a very high balance. But here you have a large balance, but you also have a large number of accounts, so probably smaller balances. So I want to have three columns in my output. So the way we do that is you would have sum over here, but then you would say comma. So how would I get this column over here? How would I get the number of tuples within each zip code? Which function is that? Right, so then I can say now count. I think I forgot my relation here before. So this is from the ‑‑ okay, so this is my relation over here. So this is the relation. So this is the second function over here. This is the first function over here. And this is the left, this is where I'm breaking my subtotals over here. And that will give me this output where I have three columns. Okay, so this is 1, 2, 3. And so this is 1, 2, 3. This is from the relation called account. Okay, so let's flip over to the exam review. I don't think anybody is really too interested in relational algebra today. You don't seem to have your heart in it yet. Okay, so on the ‑‑ let's break up the exam review into two parts. Let's review the exam procedures, and then we'll go discuss, you know, how to study and, you know, the topics. Again, all this is on Blackboard. I'm not saying anything new. Let me just share my screen. Hold on a second. Okay, you'll see my PowerPoint exam procedures. Yep. Okay, so let's walk through. So the exam is scheduled for tomorrow during our class time online on Blackboard. So what do you need? So what we're going to be discussing now is, like, you know, like what you need and how to study. Okay, so it's on tomorrow at 8 o'clock. Okay, so a couple of things you need to do administratively. Okay, so this is not a negotiable item. This is something you must do. If you don't do it, like, you're not taking the exam. Okay, so there's a very strict protocol for how this works. You need to have your camera enabled. Okay, the camera needs to be focused on your face the entire time. Okay, not your ear, not your throat, not the side, not your feet. That's focused on your face the entire time. So the camera is on the entire time. That's it. Okay, if the camera is not on the entire time, then I'm not grading your exam. Okay, so you have to comply with that. Okay, anybody have any questions about this? Okay, so the exam is timed. I'll give you about another, like, you know, 15 minutes, you know, in addition, you know, for some administrative things on the exam. But expect the exam, the length of the exam will be equal to the class time, plus an additional 15 minutes just to take care of some administrative things. Okay, you don't need to have, you know, access to, you know, to MySQL. You just need to, you know, type. That's it. Okay, you also need to have your student ID. You're going to be asked to take a picture of your student ID using, like, your camera, make a PDF out of it, and you're going to upload that picture, that PDF or that JPEG, up to Blackboard. Okay. Okay, I will also keep the Zoom session open, you know, during the exam. Okay, and the Zoom session open will be, you know, limited. You're not going to have, like, a big open discussion with the whole class asking a whole bunch of, like, you know, ridiculous questions. So the chat session will be enabled just to answer most, you know, general questions about, you know, like grammar or something may be spelled incorrectly, something like that. Other than that, you know, there are no questions during the exam. Okay, so specifically the exam procedures, and I'm not telling you anything new. This is true for any class. During the exam, I'm not going to answer questions like, is this right? What do I think of this? What does this mean? And things like that. Like, that's the exam. Okay. If there's some typo on my part or there's a grammatical error on my part, that's my responsibility. You know, I'll discuss that. Okay. Okay, the exam is the result of individual effort. Okay. You're going to have time on the exam to go off on the web searching for a whole bunch of, you know, like ridiculous, you know, things out on the web, which are all going to be wrong anyway. And I'm going to ask you definitions. This is a problem-solving exam. So any time that you spend burning through searching the web or doing other things, you're not going to find anything because there's nothing there to search. This is a problem-solving exam. You have to build something using appropriate terminology. Okay. Any violation of the academic integrity policy is that you're terminated from the course and then the college will deal with you how they deal with you. Okay. Okay. You need to have your student ID card. If you don't have the student ID card, then you're not a student at Queens College. Okay. You have to have the student ID. If you don't have the student ID, then you can't take the exam. Okay. So don't tell me during the exam. You don't have the student ID card. You only have a driver's license. You know, and this and that. You have to have the student ID. That's just the policy of the college. Okay. If you have any problems with that, like, talk to me. Okay. How does one study for the exam? Okay. As you had requested, I posted, you know, multiple previous exams, you know, before on Blackboard. Okay. And I also posted the answers. That only works if you just spend time reading the previous exams and you look at the answers and you just look at it. That's a complete waste of your time. You actually have to, like, you know, the more problems you do in databases, the more questions you answer, the more you enter, select, insert, create table, alter table, the more you do it, then, you know, the better you will be. If you just read about what I wrote and read the answers, I don't see how that's going to work. It's just not going to work. Okay. You have to do a lot of problems. Okay. When I speak to students and we have discussions after the exam and then, you know, make plans going forward as to how we make improvements, the general theme is if someone doesn't do well on the exam, it is, you know, they didn't study, they didn't do any of the practice questions, or they just, you know, you know, just did one or two questions and that was it, which meant during the exam. That was the first time they were doing something, which, you know, was not going to work. Okay. You also need to be able to move at a rapid pace. Okay. At this point in the semester, you should be able to, you know, do select, insert, update, delete, create table fairly rapidly because you've already done this, you know, like, you know, like 50 times already for multiple operations and practice questions. Okay. And also, you know, working on the project obviously is also studying, you know, for the exam. Okay. Another thing that's a requirement is the syntax. Okay. I was concerned if you miss a semicolon or if you did, you know, you know, five insert commands and you spelt insert one place wrong, or if you got select right, then one question you made a little typo, one select. I'm not that concerned about that. Okay. But if you have, like, select, alter table and create table, you're not conveying to me an understanding about the syntax. I mean, it's just totally wrong, then that's not right. So, I'm not looking at it for a typo here and there. That's less of an issue. I'm looking for the concepts. Also, you're required to use the syntax that we discussed in class. This is very important. Okay. Okay. Which means that if you go up on the web, start searching for all these crazy SQL, you know, commands, and you give me all this weird SQL that might be right but is nothing that we discussed, like, I'm not grading that. Okay. So, for example, we didn't discuss inner join, outer joins, or that type of – those types of joins in SQL. We did, you know, where table is equal to table is equal to table. So, you have to use the syntax that we discussed in class. Don't give me all types of crazy things that you typed in. I'm just not going to grade it because it doesn't make any sense. It's wrong. Okay. Okay. So, I'll pause here before we go on to other topics. Anybody have any questions? Again, I'm, you know – I got a question. It's not my intent to be, you know, aggressive here. I'm just, you know, just being straight. I'm straight with you. You're straight with me. I'm just, you know, laying everything out on the table here. So, there's no miscommunications. I'm sorry to interrupt. I have a question. Yeah. So, the practice exam that you posted on Blackboard, that's the exact same setup that we're going to have in the exam where we can, like, edit previous answers? So, okay. So, okay. So, the question is I posted on Blackboard two different types of practice exams. And with the expectation being the more questions you do, you know, the better you will be. Okay. So, I gave you some questions that are in a PDF document. I also gave you a sample Blackboard exam. So, you're comfortable with how to administer, how to take in the exam on Blackboard. I assume some people have taken an exam on Blackboard. But just in case, I posted an exam on Blackboard to give you a familiar feel for what the buttons look like, for what it feels like, and the general style. I'm not guaranteeing that every single word that's going to be on Blackboard is going to be, you know, on the exam. It's designed, you know, to make you feel comfortable with Blackboard so you can know where all the buttons are, how to advance to the next document, and how to save. Yeah, I was asking because, you know, I like some exams where after you submit, you can't go back and edit your answer. I was asking if it's going to have the same, like, Blackboard setup. You can go back. You can edit previous questions. And that's the question. So if you had 10 questions on the exam and you did questions 1 through 9, you can go back to question number 1. That's not a problem. So there's not going to be any syntax preventing you from going back to previous questions. I don't think you're going to spend that much time doing that. But if it makes you feel happy, then do that. Thank you. Okay. Any other questions before I go on to the next topic? Okay. So let me just also... Okay. So how does one study for the exam? Let me just go back to my Word document. Okay. Okay. So the topics that we covered this semester, so it's everything before relational algebra. So the topics are, you know, SQL normalization. And also we discussed at the start of the semester, you know, database management systems, database management systems. Okay. So within normalization, the topics that we discussed, and everything I, you know, said here I also have on, you know, Blackboard in the review guide. So normalization, we review the concept of a primary key and also a non-primary key attribute and a functional dependency. So a functional dependency, this allows you to determine whether or not that attribute, that column, will stay in that table. If you have a functional dependency, meaning that if my primary key, let's say, you know, student ID. So is student name functional dependence on the student ID? For each occurrence of student ID, does there exist a one-to-one relationship with student name? If that's a true statement, then it's functional dependent and that column can remain. If that's a true statement, then that column can remain and that column is normalized in second normal form. So normalization is you're applying different tests to a table, first normal form, second normal form. There are others, but we focused on first and second. And this is designed to prevent database anomalies. Database anomaly will mean that if you had a table that was not in first or second normal form. So for example, there could be a deletion anomaly. A deletion anomaly would mean that if you were to delete a row, let's say that, you know, a student is no longer, you know, at the university. So you remove the student. You don't want to remove all the classes that they took because, you know, the classes did happen. You only want to remove, you know, the students. So that would cause a database problem. An update anomaly would be that if you have many rows that would have, let's say, different, let's say, names. Let's say on some rows, you know, you had the word street. You had S-T. And so you change some rows to 1414 Main Street, S-T-R-E-U-T, and other rows had S-T. So that would be an update anomaly where you had different rows have inconsistent values. So normalization is designed to prevent, you know, insertion, updation, and deletion anomalies. Okay? Okay? So everything that you're doing in your database design, I'm expecting to be in second normal form. Okay? It's not necessary to show me how you reached second normal form unless I ask for it. But everything, like, you know, is in second normal form. Okay? So this is normalization. So I'm assuming this. Any design that you create needs to be normalized. And I will also say, you know, it needs to be in second normal form. Okay? You also have SQL. So within SQL, you know, again, in the sample, you know, questions that I posted on Blackboard, I say, like, create a database for Starbucks. Okay. So you have customers. You have products that are being sold. You also have stores. And then let's say you have, let's say, sales or, you know, a purchase. Okay? So then you have, like, a relationship between customers, products, stores, and sales. So customer ID over here, over here. So customer name. Then you have a, you know, product ID over here. Then you have the store ID. And then finally, why is sales last? Why did I make the sales last? Go ahead. It requires all the other primary keys as foreign keys. Correct. So think of sales as being, you know, the attributes like who, what, where, when. Who is making the sale? Like what is being purchased? Where is it being? And then when. So this type of design, I would have placed the word Starbucks, CVS, hospital, university. You know, it follows similar core principles. Okay? At a university, we don't call it customers. We call it students. Okay? We don't call it products. We call it classes. We don't call it stores. We call it colleges. We don't call it sales. We call it registration. But they all follow certain principles. Okay? On the exam, are we allowed to use composite primary keys? Yes. So one of the questions will be every table that you create, I'm expecting you to make a primary key. It's your design. Based upon your design, if you decide to make one column as your primary key or a composite primary key where you have more than one column, that's your design. So the answer is yes. Use a composite primary key where appropriate. Okay? So part of your being evaluated on is not necessarily the syntax. Syntax is the last part. Okay? Most of your time is spent on the design, the database. So based upon the question, you want to create the design, how the tables are organized, and then how do you determine which columns belong in which tables? How do you determine which columns belong in which tables? Normalization. Okay? The placement, the appropriate placement. So at the very beginning, if you create your design, then you want to then create tables. So syntax, create table. So be familiar with different column types. What are the different column types that you have for columns? You have an integer. That's one. What else? There's a char and then a varchar. So the difference between a char and a varchar is that if you know that you're storing a fixed value, let's say like a zip code, five digits, then that would be, you know, char five. What would be another example of a value that will always be the same length that you can make a char? Like a state. Okay. So for example, let's say like states will be like, say, you know, if you know char of two. Social security. Okay. So char of nine. Why is it social security? Why am I storing it as a text rather than a number? Social security numbers are all numbers, right? Oh, because I have a leading zero. Correct. So you want to ask the question, you know, should you use a text? Should you use a number? Text. So is every digit important? Yes and no. Are there leading zeros? Are there calculations? If there are calculations being performed, I want to get like 5% of a number. Then you have no choice. You have to use which column type? Integer. Right. Use an integer or some type of number. If there are leading zeros, meaning every digit is important and you could have a leading zero, that's just the nature of the number, then you have no choice. Then you're using what column type? Archer. So some type of text value. Char of Archer. Okay. And if every digit is important, then you want to use a text value. So keep it very, you know, follow the rules. If I'm doing a calculation, boom, two seconds, I'm using a number. If I have leading zeros, every digit is important, I'm using a text. Okay. So be familiar with different column types, you know, date, you know, Varchar, Char, you know, when to use them. So just a reminder that the date, what's the domain? What's the domain of a date? Month, month, day, day, year, year, year, year. You know, hour, hour, minute, minute, you know, second, second. So the domain means the list of allowable values. What's my domain of month, month? What's my list of allowable values? One to 12. One to 12. Right. One to 12. Right. So the key word here is what is the domain? What's the list of allowable values? And the day will be 1 through 31, depending upon, like, the month. And the hours will be, if you're doing 12 hours or 24 hours, it depends. Okay. What's the domain of state? Like the two-letter abbreviation for each state. Right. So New York, New Jersey, Connecticut, Florida. Okay. So be familiar with the term domain. Okay. So you have in my database, in addition to defining the table and the column types and the domain, you also have certain rules, constraints, and rules you're putting in place on your table. What are three examples of rules that you can put into place to enforce data integrity? Primary key. Okay. So primary key. Primary key is what is this rule? What is the rule of primary key? It must be unique. Right. So it has to be unique. And primary key has actually two rules. It must be unique and? Not null. Not null. You must have something. And it can't repeat. It must be unique. Okay. And you also have a foreign key. And a foreign key means that, you know, it has to be not null. And also, your domain is limited to a primary key somewhere else. So I can't just put in any value. It has to be only a value that's a primary key in another table. And in addition to primary key, foreign key, what's my third constraint? Null. Well, not null. It must have a value. Okay. So be familiar with your constraints. Okay. So finally, if you have your table created, then obviously, you know, you want to say, you know, insert. Insert adds what to a table? A row. Insert adds rows to a table. If I want to add a row, Joe Smith, 1414 Main Street. Joe Smith has a change of address. Which operation do I do to change a previously entered value? Update. Update. Okay. Okay. Then we also have I want to physically remove the row from the table. That's delete. Okay. Okay. And yes, I also have to decide that, you know, there are also scenarios when you need to you might want to remove a row. But if you remove the row, you can also remove important data. Okay. So, for example, if I have a table called students, I have student ID, you know, student name, you know, city. What else? What other tables do we have that depend as a foreign key on student ID? Courses in grade. Well, registration. So registration. So who is doing the registration? Well, student ID. What are they registering for? Some type of class code. Okay. So this is going to be a database anomaly. If I were to remove a row from student ID, that student like dropped out. They left the school. I remove this row. What kind of problem does that cause? You lose the other students. Okay. So student ID 100. I remove that row from here. But student 100 still exists in the registration table. So this is like an orphan record. That's a database anomaly. Okay. How do we prevent the removal of the student ID in the student table if the student ID is being referenced in another table? How do we enforce that rule to prevent that accidental deletion? I keep asking the same question in different ways. What rule can I put into place? What constraint can I put into place on student to prevent the row from being deleted here if the student ID is being referenced in another table? Foreign key. Correct. If there's a foreign key here, that's the primary key to here. I can't pretend to like remove this entire row because I have a foreign key. The system will say, no, you can't do it. I can't remove the row of students because student ID is referenced in registration. It's a rule that you put into place to prevent that from happening. Also for clarification, when you have a foreign key in registration on student ID, that also limits the like the domain for registration to only be student IDs in student? Correct. Exactly. Right. Okay. So this is delete. You have to be careful about the deletion. So how would you handle if a student like left? They're no longer a student. How would you handle like since I can't remove a row from students because student ID is referenced as a foreign key in another table, how would I track to see whether a student is gone? If I can't delete it. You can add a new column that in student and if it has enrolled or not, can have two values, either enrolled or not enrolled. So how about student like status? So student status is A for active or, you know, N for not active. Then you can keep track of that. So sometimes it's difficult to delete. You may want to have, you know, different statuses. Similar to that account open, account closed that we did earlier. Okay. So finally, now that you have data in the system and there are also only three, you know, there's only three ways of manipulating data. Using new data. So there's only three ways of manipulating data. What are those three ways of manipulating data or changing data? Is it modify? Update. Alter. Right. So there's only three ways that you can change data. Insert, update, delete. That's it. Okay. And you also have searching. So alter table that you just said. Alter table has nothing to do with data. Alter table does what? Alter table just alter the column. Right. So it changes your table structure. It adds a new column, increases the column length, removes the column, changes the column type. It's not changing your data. It's modifying the structure of the table. So be familiar with the distinction between alter table, the structure, versus, like, changing data in the table. Then finally you have select. Select is the ability of searching. Okay. So you can search from either one table or you can search from multiple tables. Students, you know, comma, class, comma, registration. I can only search from multiple tables if what's true. If what's true. I can only join multiple tables if what's true. They have a common column between these two tables. So, you know, so students, you know, dot student, you know, ID is equal to registration dot, you know, student ID. I can only join where this is a true statement. Okay. So be familiar with, you know, searches. This is a good part of your output. You know, often you'll say make a design using create table. That's normalized. Primary key, foreign key. Put all your constraints on it and then do some searches or make changes to your data. Okay. You also have functions. So functions is the ability of getting aggregate information. I want to know how many rows. Let's say like the number five. So you have a function called, you know, count. A function called max. A function called average. A function called, you know, sum. Okay. So, for example, select, you know, sum of, you know, balance, you know, from account. This will total up all the balances in the account table. Where? Only for New York customers. You can do that. Okay. So focus less on definitions but more in terms of, like, how do you utilize your toolbox of operations? Insert, update, delete, select functions in order to answer certain questions and do analysis. Okay. So what I recommend is obviously you have the class recordings. You have all the, you know, practice questions I posted on the Blackboard. You have the project. You have all the, you know, questions in the textbook. So be familiar with all that. Okay. The more questions you do, the more problems you do, the more relaxed you'll be, the faster you'll go. You know, common mistake is that you're doing it for the first time during the exam and you get very slow and you spend, like, a half hour on the first question. Okay. So I'll pause here. Anybody have any other questions? Yeah, Professor, one last thing. So, like, the practice PDF that you posted, like, our database design or structure doesn't need to match exactly how you have created, right? It can vary in specific ways once we get the same output.
