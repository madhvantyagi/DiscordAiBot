The objective for today is to continue our discussion about concurrency. Specifically, we're going to convert the pseudocode that we did for two transactions and figure out how concurrency operates within SQL. So how do we convert the pseudocode into MySQL SQL statements? So let's take a look at these two transactions. So what are your thoughts about how we convert this statement, I'm sorry, this transaction, transaction number 1 into SQL? So what is actually happening here to the table? What are the operations that we're doing to the table in transaction number 1? Update. Doing what? An update. Okay. So we're doing some type of update. So what table are we trying to make a change to in this transaction? The table called the account table. So which row are we trying to make the change to in this table? 200. Row 200. So row 200. Row 200. So that's written like in this line. So balance 200. So balance 200, this is right here. We're also performing, let's go through each operation here. So we're doing a read. So we need to retrieve data from the account table. Then we need to do a calculation. Then we need to write the results back to the table. So what column are we changing in the account table? We're reading from the account table, we're accessing 200. What column are we making a change to? Balance. Make a change to the balance column. Okay. So what operation do you know allows you to make a change to the balance column in a table on a specific row? Of the SQL operations that we know. Update. So these are pretty much most of the operations that we know here. So update allows you to make a change on a table. So what are we changing the balance column to? To the 20,000, 20,000. We're doing calculation. We're minusing 25. So it looks like something like, so help me, give me the actual SQL. We're minusing $25 from the balance column in the account table for row 200. What's the SQL? With update table account. Which column are we changing? Set what? Set 200, set balance 200. So balance is equal to balance minus which row? Account number equals 200. So this is the SQL. So how about this right lock up here? What's the purpose of this right lock? What are we trying to do here? Lock the balance from changing or from accessing? Well, we're requesting a lock. It's not going to be automatically granted. The right lock is we're requesting a lock. So to prevent other transactions from making a change to row 200. So we're making the request over here. Then we're doing the read, we're doing the balance, we're doing the write. So this is all the update commands. Then finally, we say that we're done. So how do you want to implement blocking within SQL? We have to make the request. So who do you want to manage the lock requests? You want it to be you, the SQL database administrator, or you want it to be somebody else? Who's going to manage these lock requests? Can the computer do it? Okay. Why can't you do it? Because there's a lot of them. Because we can't handle one lock. But what else are you doing? I mean, you're entering the SQL command. So why can't you be responsible for requesting a lock up here? Then when the lock is finished, you can release the lock at the end. Why do you have to have the system do it for you? Why can't you do requesting a lock and then releasing a lock? Transactions happen anytime. So we have to be there when it happens. So it's better to automate it? Okay. Fair enough. What happens if you're responsible? Let's say that you would just put the code in. You're responsible for adding the code to request lock, and at the bottom, you can say release lock. Then you're responsible for entering these SQL operations to request a lock and release a lock. What's the advantage to this? What's the disadvantage to this? You can answer all questions a computer is based on speed course for liability. Well, it's down to that. So if you were to be responsible for the SQL code, and you're also responsible for request lock, so how would you evaluate this? Does it impact speed if you were to request it and release it? Yes. How does it affect the speed? I mean, I'm just typing in the command, request a lock and a release a lock. How does that affect the speed? I guess no. How about reliability? Reliability means, am I getting the right answer? Yes. Yes, good impact. Give me a scenario where this would not be reliable, where you would not get the right answer, meaning you are typing in all these operations, you're responsible. Give me a scenario where this would not be reliable. Is it when there's 10 transactions, like 50 transactions in a shorter period of time? Well, it just means that the transactions would execute in a certain order, and then you would have to enter this like 50 times. So give me a scenario where this would give me the wrong answer, meaning it would not be reliable. It didn't request the lock first, but release. Let's say you, the database administrator, you did the update command, but you forgot to do the request a lock. The update command will still work, but you never did a lock. So what's the impact of that? If you are responsible for typing it, what's the impact of missing the lock request? You can get the wrong balance. Right, you can get the wrong balance. Okay, so who do you want to manage the locks? You, the human being, or somebody else? Somebody else. Okay, you want to have the system. Because this is such a critical operation, the system, you know, MySQL and Oracle and other databases, they're not going to rely upon you, the human being, to manage the locks. Because if you screw it up and you forget to request a lock, you get the wrong answer. So the system, the database, every time you make a request to do an update, behind the scenes, the database will make a lock request on your behalf. So it takes care of this automatically and it's programmed. Okay, that way you don't have to worry about making a lock request. So which operations in SQL is it necessary to request a lock? I have select, insert, update, delete. Insert. When you're updating? Well, whenever I'm changing data. Okay, if I'm making a change to a row of data. So which operations allow me to modify data? Update. Okay, so update, that's going to modify data. So how about delete? Is delete modifying data? I'm removing the whole row. So then, yes, I'm modifying the data. Okay, and also insert. Like I'm adding new data, that's also modifying data. So this is also. How about select? Is select modifying data? No, but you can't modify data while someone's selecting something? Right, so select is just looking at data. I'm displaying it. I'm not making any change to data. So requesting a lock to ensure you have exclusive access to this row when no other transactions will access it, that involves these three operations, insert, update, and delete. Locks are required because changes are being made to the data. If you're doing a select, then no lock is required. Okay, so this is the SQL in order to do this operation. So what's the SQL for this transaction? What's the SQL for this? What table are we making a modification to? Select account. Which table are we making a modification to? Isn't it the same one? Right, so it's the account table. So it's the account table. And which row are we making a change to? Which row are we making a change to? With 200. Which column are we making a change to? Balance. Okay, so sounds like update account. Set balance is equal to what? What changes are we making to the balance? Setting 50. Right, so balance plus 50. But which row? Where? Okay, so this is the SQL. With this pseudocode. Okay, we have one more operation. At the very end, we say commit. Commit means you're affirmatively saying, I am making this permanent. So commit means you're doing that. You also have the option, if you don't say commit, you can also say rollback. Meaning that you're changing your mind and you're reverting back to the last commit point, which is what the value was before you did the update. Okay, so let's actually do this in MySQL. Remember, transaction one, you have transaction two. Okay, so I have MySQL running over here. Okay, everybody see the MySQL window on the screen here? Yes. Okay, so right now, I'm logged in once. I made one window to log in, okay? So at the main system, I logged in here, click, click. So here I am. So I can say use CS, you know, show databases. So I want to log in, I want to use a database called CS331. And I can show my tables in CS331, and these are my tables. Okay, so I'm logged in. So I want to now log in and have another transaction connect. I want to have two logins. So let's do this. Let's do a new operation. I want to make a new user in the system. And then I'm going to log in as that new user. So I'm logging in as, here I'm logged in as administrator. I'll make a new user. Let's say I call this new user, let's say Sally. I'll log in as Sally. Then I'll have two SQL windows open, two transactions. So let's create a new user. Okay, so here's some code I'm going to be using over here. I'm just going to copy paste it over. Okay, so the syntax, there's a new command. Just like you can create a new table, you could also, an object is a table. I also want to create a new user. So the syntax is create user. Let's say I'm going to make the user, your name is called Sally, and I'm going to give the password. Okay, so this is not an uncommon process. If you're a database administrator for an organization and you're responsible for adding users, let's say a new employee gets hired, you're going to create a new user for this new employee so they can log on to the database. Okay, so I'm going to execute this. So the user is created. Now we also have to decide what can this user do in the system? Everybody's not going to be an administrator. Some users could access only certain tables, certain databases. They can do a select command, but not a delete command. So we'll spend like a whole week talking about security, but right now I want to allow this user Sally that I just created to have like all privileges. So I'm granting all privileges on this database, CS331, to Sally. And I'm logged in as the administrator. So only the administrator has rights to create other users or give birth to other users. This is a powerful, that's why the database administrator for the database, it's a powerful operation because you could change passwords, drop users, create users. Okay, so I just created a user and it was successful. So remember, Sally, Superman. So now if I go back to the main screen up here, and if I look at my previous connection, so here I entered the password. So I have local host, standard TCP IP. So I'm going to make a new user plus, and I like to put the user in the title up here. So I'm logging in as Sally. And if I want to test the connection over here, so I'm going to enter the password. Superman, I'm going to save it. Okay, successfully made the connection. That's always good. And now I'm going to say, okay. Now I have a user over here. I have a connection information. So now I'm going to click, click. And I don't know where that came from. So if you look very closely at the very top, see a new tab is created at the top called Sally. See a new tab is created at the top called Sally. And then the other tab I was connected to over here, this is my administrator account. Okay, so now we have two transactions. This transaction here, and I changed my tab, because of the connection called Sally. Okay, so notice how Sally only has access. Why does Sally only see one database? But this user over here sees Baseball CS331 and sees this. Why is that? Why does it use a Sally database, but this is user, the administrator sees three databases on the left. Because we granted Sally only one database. Right, so grant privileges on CS331 to Sally. So Sally could only see one database. Okay, so let's do a test. I want to use, you know, CS331. Okay, and show tables. Okay, so I granted Sally to see all tables. So now I want to look at the table called, let's say customers. So select star from customers. So you have to like, you know, follow this carefully, because we have to, not only do you need to monitor what table I'm accessing, you have to also keep track of from which transaction am I making this request. Remember, it's one table, table called customers. And I'm looking at a Sally. How many rows does Sally see in the customers table? Is it seven? Okay, give me the SQL operation to confirm that. Select on star from customers. Okay, so I have seven rows. Great. Okay, and if I log in as this window over here, and if I would say select star from customers, so I see the same ones. Okay, so let's try some operations now, and let's see how the system handles two transactions trying to access the same table. I want to do one thing first. It is one operation, which is like, I find totally strange that by default, MySQL will auto-commit everything you do, auto-commit. What do you think about the system automatically committing everything you do? What do you think about that? It can make changes without our confirmation. So changes that we don't want. Right, so it automatically be making something permanent before you have an opportunity to actually confirm and validate it. So it's convenience is taking the burden of having to you type the commit command, but then everything you do, insert, update, delete, it will automatically commit. What do you think about that? What's your opinion? We'd like to know. It's dangerous. Yeah, I think you, the database administrator, you should have the flexibility to decide, you know, whether you want to make it permanent, you do an analysis. So I'm going to turn off the auto-commit, okay? I would recommend you turn off the auto-commit. And so I'm going to say auto-commit zero. So in this user over here, I'm going to say auto-commit zero. So it's turned off. And in Sally, I'm going to also say turn off the auto-commit. Personally, I think this is like dumb. In order to auto-commit, I'm baffled as to why this is the default setting. I mean, it's like, you know, it's certainly convenient, but I'm just baffled. Okay, okay, so it's turned off. Okay, so I want to now, I want to add a row. To the customer table. Let's get some more people involved in this discussion. So Matthew, Naeem. Sunny. So help me out here. I want to add a new row. Insert into customers, values. Oh, you could put the columns too. I guess you don't need the column names. Values. Okay, so give me, give me a, add a new column. I'm not sure where I'm going. Okay, so I'm going to add a new column. I'm going to add a new column. I'm going to add a new column. I'm going to add a new column. Give me a, add a new customer. Samantha at Yahoo.com. So credit card expire. I'm going to say no. Type. So I'm going to say like no. Okay. Okay. So I have email customer first. So email first, last, credit card, expire, subtype. Okay. Done. So at the very bottom, see how it says one row inserted. How can I confirm this row was actually inserted? Select start from customers. Let's start from customers. So there it is. Samantha, Samantha Jones. I also, so how many rows do I have here? I have eight. Okay. Which transaction am I connected to and displaying right now? Where I did this operation? Sally. I'm connected to Sally. Okay. So this is what it looks like from Sally. Is this row that I just added, is this a committed value? True or false? False. Right. It's not a committed value. Okay. And so what rule did we establish on Monday? So what rule did we establish on Monday? Each transaction should only view which type of values? Committed. Committed values. Okay. I'm going to log in as this other window. So I'll log in as administrator here. So remember, different window. So let's start from customers. So what's missing here? So where's Samantha here? Not in the table. Not in the table. How many rows do I have in this table? So select count from customers. I have seven. I go to Sally connection and I say select start from customers. I see eight. Remember, it's the same table being accessed by two users in two transactions. Why is that? Why is Sally, why is this administrator, this window, why is there no Sally, why is there no Samantha being displayed here? Because the row is not a committed value. Correct. So from Sally's point of view, Sally can see all the rows. Sally will see all committed rows and also all rows that Sally added that are uncommitted. So Sally sees everything which is committed on the table and also any uncommitted values that Sally happened to enter. But the administrator was in another window. It just happens to be an administrator. It could be somebody else. So she's only committed values and anything that's not committed by the administrator. So it's this. Okay. Let's do another one. I want to add another user. Who am I logged in as now? Which transaction? Administrator. I'm his administrator. So I'm going to. Okay. Okay. So adding a new customer, you know, so both. One row added. If I were to say select star from customers, where is it? Right here. Now if I were to go to Sally and select star from Sally, I don't see it here. It does then Sally see the new row that was just added by the administrator. Hasn't been committed. Correct. So you just keep following this rule that each transaction only can view committed rows and any uncommitted rows that happen to be entered by that user. Okay. So let's keep going here. Okay. So let's say that I'm going back here. So how do I make this permanent now? So the administrator says they want to make this new entry right here permanent. How do we do that? Is it commit? So commit. Okay. Commit successful. If I were to say select star from customers, so I still see it here. Remember I added the user, this user right here. Now remember I just committed. I go to Sally, go to the other transaction, select star from customers, and did I just commit that? So say commit. And if I were to go over here, select star from customers. Where is it? So I did O-L-E-E. O-L-E-E. Anybody see it here or am I just missing something? Let's say that's strange. So let me count up the customers. So I have eight customers here. And if I were to count up from here, here I have eight customers. So where is it? O-L-E-E here. Select star from customers. So now it's over here. Now it's here. Let's check my Windows here. Okay. So now we have it. Okay. So let's make another change here. Besides adding a new row, what other operation can I use to change data in my table? Insert is one. What other operation requires a lock besides insert? A lock is only required when I change data. There's only three operations in SQL that change data. Three operations. Update. Okay. So we have to update. Okay. Let's say I want to change this last name from Jones to Smith. How do I do that? How do I change Jones to Smith here? What's the update? Okay. Alvin, Amelia, Aaron, help me out here. Change this to Smith. Only for this row. What's the update? Customer last. Right. Maybe we have to update the customer table. Which column am I changing? The customer last. I'm changing the customer last to what new value? Smith. But which row? Can it be where customer first equals Samantha? What happens if I have many customers called Samantha? Isn't the primary key the email? Okay. Okay. So we say and email is equal to. So that means this must be true and this must be true. Okay. So I'm going to update it. And then it said syntax error. What's my syntax error? When you change something. Look at the code. It says customer doesn't exist. I'm looking at the bottom here. Oh, it's not created. It's customers. Okay. Is it done? How can I confirm this was actually executed? The last name was changed. How can I check that? Every time we do a change, it says validate everything. So let's start from customers. So Samantha Smith, done. Okay. Is this change I just made, is this a committed or uncommitted value? Uncommitted. Uncommitted. So if I were to go to this other user, administrator, if I were to say select star from customers, I'm getting my users mixed up here. Is this the user I just did here? So this was Samantha. So where's Samantha on that list here? Oh, here. Okay. I think I messed up this database by messing around with this auto-commit here. Because I'm supposed to be seeing, like, Samantha. But if I go to this other user, and I'm connected here, so star from customers, don't see Samantha. Oh. Okay. Let me just have another user over here. Let me just do this one. It's like star from customer. Okay. So I have another user here called Bob. So I have Sally and Bob. I'm not sure what's going on here. So now Bob, I see Samantha, and Sally, I see Samantha. So what happens if I were to, let's say, delete? So delete from customers where email is equal to. Okay. So now if I look at it, select star from customers, I don't see it here. I just deleted it. But if I go as the other user, select star from customers, I do see Samantha. Why is Bob, my other user, seeing Samantha, but Sally does not? Who performed the delete? Which user? Sally. Right. So the Sally transaction. So from Sally's perspective, Sally will see all committed rows, plus any uncommitted values that Sally did herself. But Bob, which is another user, Bob only sees committed values. So that delete wasn't happening. Let's try this. Bob now wants to change, let's say, the last name for Samantha. So update. So update customer last from customers where email is equal to. Okay. Who am I logged in as now? Which transaction? Bob. I'm Bob. Okay. So if I were to now execute this. Is there a SQL error here? Is there a syntax error here? What's wrong with this update command? Let's go, folks. What's wrong with this update command? Update what? What's supposed to go here? Right. Table name. So customers. Right. So I'm setting customer list equal to. I want to say. Okay. So the syntax is update the table, send a new customer to this, sit over here. Okay. So I'm going to execute this. Okay. So if you look at the bottom of the screen, what's going on here? It didn't actually execute, but it has the word running. Why is it taking so long to execute this? It's running. And then if I were to go to this other user, like Sally, And if I were to say, you know, select star from customers. So remember up here we had deleted this. So this user, Sally, doesn't see this customer. What kind of transaction is this? Is this a committed value or uncommitted value? And it just did. Committed value. Well, I have commit here, but I never actually executed this. So I just did this. I never said commit. So not committed. Right. So this is an uncommitted value. So remember, Sally doesn't see Samantha. Because Sally sees committed values in every change that Sally made. But Bob, you know, did see Samantha. And then notice how this is still executing. Well, actually, it actually timed out. Why did this message time out? Lock way time out exceeded. Try restarting the transaction. Why did it say that? Why was there a locked time out? Maybe Bob didn't got the privileges. Well, Bob has privileges to perform updates. But this row was what type of row, what type of value is Samantha? Sally deleted it. So it would say uncommitted transaction. But Sally never committed this. So from Bob's transaction, Bob is attempting to delete a row. But why can't Bob perform it? Why was it attempting to do a lock and the lock timed out? Because that was never committed. It was never committed. So who owns the lock? Sally. Right. So Sally owns the lock on the row for Samantha. Why does Sally own the lock? From what operation did Sally get a lock? Like the members. Right. The delete. There's only three commands that issue blocks. Insert, update, and delete. Sally requested a lock and it was granted. Was the lock ever released? Did Sally ever release the lock? And only which two operations released the lock? Submit. Or? Rollback. Correct. Rollback. Let's try this again. I'm going to do this update again. Basically, it didn't work the first time it timed out. I'm going to request it. So as of right now, does Sally still have the lock on the row for Samantha? The answer is yes. It was never released. I'm logging in as Bob. Bob, is that showing the update command? So it's running. So how can I make this execute? So Bob is waiting for what to be released. Sally's lock to be released. Right. How can Sally release the lock? From the commit. I can say commit. So I'm going to say commit right now. So it's done. Commit is executed. So now if I go back to Bob, notice how it said it actually did the update. See, that was how it actually finished. Okay. Okay. But what's the message? How many rows were actually updated? One. Well, look at the screen. Zero. How come there was zero rows updated? Does this row exist anymore in the table? Select our customers. Something is screwy here because I see the row over here, but then I go to Sally over here. So the row doesn't exist. So the update can't be performed because the row doesn't exist. I have to do some research just to find out why when I do a select from here, I'm still seeing it. Something is wrong with the locks here. Okay. So I just wanted to introduce that how do you make more than one transaction on your system. So the way it is, you could make another user. So, for example, create a user, and then you'll log in as that other user. Let me just go back to this. So let's talk about the different, like, levels of locking, or what's known as the granularity. The granularity. What's that row? Granularity of locking. So what's the lowest level lock that I can perform? So it's like one row. I can't lock a field. I can only lock an entire row. If you were to figure out in a database how to lock one field in a row, that would be a great invention. You'll be the first one to invent that. But right now, the lowest lock is on one row. What's higher than a row lock? Table lock. So table lock. So give me a command that will lock all rows in a table. And before you answer, remember, there's only three operations that will request a lock. You know, insert, update, delete. Those are the only three commands that actually change data. Okay, so which operation? Give me a SQL command that will lock all rows in a table. Give me a command that will change every row in a table. Delete. Okay, so delete. So let's say I have my customer table. So logged in as Sally. So let's start from customers. I have a total of 1, 2, 3, 4, 5, 6, 7, 8. I have eight rows. So I would say delete. But by the way, before I start deleting data, let me make a copy of the customer table. It's always a good practice. So new operation. I want to make a copy of a table. So what command do you know allows you to make a new table? Create table. Create table customers to. You know, just a name I made up. And I want to the data in the customers to table will come from which table? Customers. Right. Select star from customers. So I'm going to take all the rows that are output from this select command, and I'm going to add it to the customers table. And the customers table will have the same table structure, same column name, same column length as this table right here. Okay. Looks like I have a running command here. So this looks like I have a lock, which I kind of probably forgot about here. So let me just like commit on this end. And let me go back here. And let me do a commit over here. Okay. So I committed everywhere. So I committed. Committed. And it's running. The lock timeout exceeded. I'll tell you what. Let me do some research and figure out, like, what's going on. I think I messed something up here with this auto commit. I turned it off. I did a setting. So, but the bottom line was doing a, like, a delete command. That will put a lock on all the rows in the table because a lock needs to be requested on every row. What's another operation that can be used to lock all rows in this table besides doing a delete? Update. Okay. So give me an update that will lock all rows. Set what? Balance. Ego to balance plus one. Where what? Account number. So give me a true statement. Give me an expression that will be true for every row in this table. It's not null. There you go. So this will lock every row in this table because this where clause will be true for every row. So there's a, you know, there's a lock, lock, lock in place. Okay. So then if anybody were to then subsequently, you know, do another update, another transaction, were to do an update on this row because there's a, this is an uncommitted value and there's a lock in place, the other transaction would wait. Okay. So I do remember like often, like I would be in the office, I would be working on my database, and then I would like leave. I would head out to the college, come out on the F train, and when I came out on the F train at Forest Hills, like my phone is ringing. And people are telling me they can't get into the database. They are, quote, frozen. That's their interpretation as to what's happening. So when they tell me that their systems are frozen, what's really going on? They don't have the privileges to access? Well, they have the privileges, but they're trying to access a, they're like, they're waiting for the locks to be released. So I did an insert, update, delete, never committed it, so it meant everybody else was locked out of the system. Okay, so we'll spend some more time, you know, talking about this. So I just wanted to introduce the concept of it. So in addition, what's higher than a table lock? So we have the lowest lock is a row lock. Higher than a row lock is a table lock. What's higher than a table lock? Database lock. Database lock. I want to lock every table and every row in the database. Why would somebody need to lock every row and every table in a database? We didn't actually get to this topic yet, but it's a concept known as a backup and recovery. In order to perform a backup of the whole database, I don't have a copy in case anything happens, in case there's a disaster. I need to, like, freeze all my tables, freeze all the rows, to make a consistent state. So when a backup is performed, you know, you have to put like a lock on all the rows so nobody makes changes. I mean, there are ways around all that. That's something which also needs to be done. Okay. So let's also discuss that when I do a write lock, which is known as an exclusive lock, which means that only one transaction could access that row that was locked at a time. So write lock is an exclusive lock, it's one transaction. Let's say that I want to do a select. How many users can perform a select on a table at any one time? Select changing data, true or false? False. Right, select's not changing data. So this is, so a select is going to give, like, a read lock. So read lock means that many users are able to access that row, but they can't make any changes. They can't make any changes. This is not an exclusive. And then, but how many users now could access that row that has a non-exclusive lock? Because I'm doing a commit. How many users? So if one user means an exclusive lock, because I'm insert, update, and delete. So if I have a non-exclusive lock, like a select, meaning I'm not making any changes, how many users could access as a result of a read lock? Any amount? Right, many. Okay, so there's no restrictions for a read lock. So you have two different types of locks that you can request. One is a write lock, and the system will request this on your behalf or insert, update, delete, which is an exclusive lock, only one transaction. And then if you're doing the select, this happens more in the background, the system would, you know, request a read lock. It would allow many users to access it. Then when you're done, it would release it. So everything stays, like, nice and tidy. Then you would have, like, a queuing system that if somebody tried to access a row that was locked, you would have to wait. So you wait in a certain order. Whoever makes the request first waits first. Whoever makes the request second waits second. Okay, kind of like a printer queue. Okay. Okay, so we'll spend some more time, you know, talking about, you know, concurrency and spend some more time doing hands-on, and I'll do some checking about how I messed up my database here. Okay, so I'll stop the recording and stick around if people have questions.
