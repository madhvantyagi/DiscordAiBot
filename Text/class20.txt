All right, can everybody see my Excel screen? Okay, hope everybody's doing well today. The objective for today is to continue our discussion about backup and recovery, and there are some specific scenarios, specifically when we say a document is committed and it's lost in memory, but it doesn't actually get saved for several scenarios, like how do we recover data? So, we have different, you know, in addition to disk, if data gets lost in memory. And so, before we get started with that, on project two, does anybody have any questions that we could discuss together? In their normal form, we can get an example of it, please. Okay. Let me do that more towards a later part of the class. I'll do that. Okay. Thanks for reminding me. Okay. Anybody have any other questions about project two? Okie-dokie. Okay. Okay. So, let's do a, the scenario where, what's the process when documents are saved to a table? Let's understand the actual MySQL architecture and the relationship between memory, processor, and storage. Okay? So, let's have a, let's do the scenario where, let's say we have a table, and we have the account table, and the account table has, you know, account number, owner ID, balance customer first, customer last. So, this is the account table. And then we have, I just represented the same table, you know, down here, and I just put in six rows. Okay. So, this is what it looks like. Okay? So, what happens when I insert a row into the table? Okay? So, let's analyze where the data gets saved. So, whenever we save the data, like, data is saved to our storage device. So, let's say that we have our storage device, so this is a, our magnetic storage device over here. Okay? And as you know from your operating systems, you know, discussions, the documents are organized, not documents, the files are organized on the storage device in terms of blocks. Okay? Blocks. So, for example, you know, this is block number four, block number three, block number two, block number one. So, each unit on the disk is called a block, and the disk spins, and then as the disk spins, the rewrite head, you know, saves data to the, to the block. So, let's figure out, like, how that, that actually works. So, we have the concept of a block, so we have a, so one, the one block, and typically the operating systems have a block size of about, let's say, 4K or let's say 8K or 16K. So, rather than save one byte of data at a time to a disk, we're saving, like, one block. We're writing 4,000 bytes, and we're reading 4,000 bytes. We're writing 8,000, we're reading 8,000. So, when I create this table, the account table, we need to specify, well, I'm sorry, when we create the account table, data in this table, these rows, are saved to a block, okay? Now, so, for example, you know, 111111, account number 111 is saved here, and we have, you know, you know, Sally Smith, account number 333333, and, you know, Beau Blake. So, I'm filling up this block with data. So, this first row, how much storage is required to save this first row, exactly? Where would I look to identify the amount of storage for this? Sonny? Is it the chart? Excuse me? Is it the chart on the right? What right? That circle. Well, this is where we save our data, but I want to know, when I save this first row, how much storage is required? Kelly? June? Jocelyn? Hanlon? You look at the variable type. Okay. So, for the first, so how much storage is the account number going to be based upon the definition up here? So, we have a number. From your experience, how much storage does a number take? How many bytes? If it's, like, an unsigned, it's 16 bytes, or, like, long unsigned, 16 bytes. Okay. So, that's a pretty big number. How about we just keep it simple? How about we keep it, like, you know, what number could be one byte, two bytes, three bytes, you know, so it could be large. Okay. So, let's say a number is going to be four bytes for a very large number. And this is the same thing. I want to write D as four bytes. And then we have a decimal, let's say it's also four bytes. How much storage will the first name and last name require? How many bytes of storage? What does it say here? What is that number? 30. Right. So, I'm allocating, at most, 30 bytes of storage, at most. And last thing. How much am I allocating, at most, how much? 30. 30. Okay. So, the sum of storing one record, let's say 72, 72 bytes of storage. Okay. So, it's, like, 72, 72, 72, 72. So, I can keep saving records until my block gets, my block gets full. So, if I'm allocating one byte, which is, one block, which is 4K, so 4K, so K is really what? 4,000. But K is really, like, 1024, you know, like, two to the, you know, power, you know, so it's really, so it's really, like, four times 1024, so it's almost 4,000, so it's 4096. I'm just being exact here. So, 4K, you know, is really 4096 bytes. So if I were to take 4096 and then divide it by 72, so I can store approximately, you know, 56 records. Okay. So, 56 records per block. So, what happens when I enter the 57th record? Where does this, that record get stored? You need a new block? Correct. So, all blocks have, like, a designation. So, this would be block number one. Just give it a number. And another block is created, block number two. And I can add another, you know, 56 records in this block. And then when this block is full, there's no more storage, then it's like block number three. I can keep creating blocks as more rows are being added. So, the relationship is, when you create a table, table has the fields. Fields have a certain amount of storage, like up here. And then when we say save, insert the row into my table, you know, it's really added to the block. And then the block gets written to my storage device. Okay. I'm just going to, you know, so my block is written to my storage device. And we also have to allocate and designate for each row, where is my block located? So, let's say for this discussion, we decided to say block number one, like right over here in number one. So, block number one, block number one, one, one, one, one. So, all these rows are added to, you know, block number one. Let's say that I, you know, you know, a couple thousand blocks later, I add another block in another, you know, row. And let's say it gets saved to block number five. Okay. So, I have data in, I have data in block number one and also data in block number five. Okay. Okay. So, what's the limit? How many, how much data, how many rows can I add to a table? What's my limit? Okay. Everything has a limit. How many, how many rows can I add to a table? What's my limit? Until you run out of storage space. So, until I run out of storage or until I can't allocate any more blocks. So, what's my, what's preventing me? So, when this storage device right here, let's say this is a, you know, four terabyte storage device. So, once I run out of blocks on my four terabyte storage device, then what happens? Okay. The system doesn't allow any more new blocks. Okay. So, solve that problem. I have a four terabyte storage device. I saved, you know, millions and millions of rows and I have no more blocks to save in four terabytes. But obviously, my business is growing. I'm adding more and more transactions, more customers, more products. So, I need more blocks. I need more rows. Solve the problem. I'm giving you money. Buy more storage devices. Buy more storage devices. So, then if I just get another four terabyte storage device, then I have more blocks. So, what is really my limit? As to the amount of rows I can add to the table. How much money I have? How much money you have. You can just keep buying more storage. Obviously, there's some theoretical, there's some limit. I can't put in, I can't, like, add, like, not, like, 100 trillion, like, rows to, you know, to a database. There's always, you know, it's a finite amount of, you know, it's a box. It's a storage. So, either until I run out of money or until the database can't access that much storage. Like, there's some, like, limit. All databases have a limit as to how much storage you can access. Okay? Let me just do a quick calculation. So, how many, how would I calculate on a four terabyte storage device, how many blocks are available? What would be the calculation? Not four terabyte storage. How would I convert that to how many blocks? Help me with the math. You have to convert terabytes to bytes first. Okay. So, I'll do four, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero. So, is that four? Four, zero, zero, zero, zero, zero, zero, zero, zero, zero. So, is that four? Is that four trillion? Help me count that by zero. So, this number is what? This is four billion. So, this is 109 million, 109 billion. So, this is four terabytes. So, I can take this number, okay, this number times 401024. So, this is the amount of storage. Like you said, I converted this to bytes. Now, how would I convert this to how many blocks? What's my block size? 4096. Okay. So, 496. Okay. I just happen to have four terabytes, which happened to be 496, and the block size is 4K. Okay. Happen to be the same. So, doing some division, so I can allocate, what is that number? Is that a billion? One trillion. Wait, so it's like one trillion? Okay. Okay. So, this is how many blocks I can allocate. Okay. So, let's keep going. Okay. Okay. So, let's say that I were to keep adding more rows. So, as I add more rows, I'm adding rows to, so the blocks get full, okay? So, as time progresses, more and more blocks are being used. Okay. Let's say that we have another table. So, let's say we have another table called product. So, what are some columns I can add to my product table? Give me some standard columns in a product table. Product ID. Okay. What else? Price. Price. And give me one more that I must have. Name. What's my column type? Bar chart. Okay. Okay. So, let's say the first column will take up, let's say, 4 bytes of storage as a number, 4 bytes of storage as a number, and 30 bytes. So, one row will contain, at most, 38 bytes of storage. Okay. So, when I begin to add data to this table, where will these blocks be saved? Where will these blocks be saved on my storage device? I do an insert command. Insert into product. You know, values. So, then it gets saved. So, I need to insert. It gets saved. So, which block is going to be designated to store rows for the product table? Any that's free. Okay. So, any blocks that are free. Okay. So, I have some blocks free here, here, here, here, here. As more blocks get allocated, then some blocks are free over here. Okay. Then, as time progresses, more rows, my business is expanding, I'm adding more accounts. Each customer has, like, an account on the system, so I add more blocks. Okay. So, then, some more blocks get allocated. And also, as time progresses, I'm adding more, many more products. Okay. Okay. So, each row that gets added, the data gets added to a block, blocks get saved. When this disk gets full, I can buy another disk. And this goes on and on and on. Okay. So far, so good. Okay. So, this is how the underlying architecture works. Let's say I want to not do an insert, but I want to perform a... I want to increase the price of a product. Okay. So, I want to increase the... Let's say this, the balance, right here. So, I want to add $50 balance to this right here. What is the process? Give me the SQL to add $50 to this account. Okay. Do you need an update? Update what? What's the table? Product. Well, I'm adding $50 to this. Oh, sorry. Account then. Yeah, keep going. Set balance. Balance plus... You said 50, right? So, 50. Where account num equals six ones. Good. Okay. So, this is the... The process will be, you know, add $50 to account number one. And this is the underlying SQL. So, what happens in the architecture? Okay. So, step number one. Let's write down our steps over here. So, step number one. We have to identify like, what table? What table is used in this SQL? So, what is the table? Account. Okay. So, it's the account. Okay. So, we're... I'm doing a calculation. I'm adding $50. From your experience with computers, where are calculations performed? CPU. Excuse me? On the CPU. Right. They're in the processor. Okay. So, before you do your calculation in the processor, the CPU, what needs to happen? Where do you have to bring this data? This data. Into main memory? Correct. You have to bring data into memory. Where does the data currently reside? The magnetic storage device. Correct. The data exists in the magnetic storage device. So, you have to identify so, what... So, what is the location or the block or the row? Which row am I accessing? Which row am I doing a calculation on? Row 1. Right. I'm looking for row 1, 1, 1, 1, 1, 1. So, where is block number... Where is account number 1, 1, 1 located? What is the block that stores this value 4,000? Block 1. Block number 1. Okay. So, it's like on my disk, block number 1. Okay. So, what is location block number 1? So, block 1. Step number 3. Now that I know where the data is, the value of 4,000, it's saved to my storage device, now what? What do I have to do with this block in order for me to perform this calculation? Remember, the block exists on my storage device. I need to do what now? Bring it into main memory. Correct. So, am I moving the block or copying the block into memory? Copy. Copy. Okay. So, copy the block from where? From storage device to main memory. From block 1 on my storage device to memory. Okay. So, there's a area in memory that's reserved for the database blocks. So, this is known as my database block buffers. So, we can diagram it. It will be like this. So, block number 1 will be brought into memory and then we're going to designate block 1 has been copied here. So, block 1 is now in memory. Block 1 is... What is the size of block 1? 4096 bytes. Right. Or 4K. Now what are the two locations where this block resides? I have two copies of this block now. Where do these two blocks reside? Main memory and the magnetic storage device. Correct. Block exists in my storage device and in memory. Okay. So, as long as we're talking about memory, what else do I have in memory at this moment? Okay. I power on my computer. Let's say this is my memory right here. Let's say I have 128 gigabytes of memory. Probably more than what you have on your home computer. You probably have on your home computer, you have like 8 gigs or 16 gigs of memory. If this is a database server, let's say it has a lot of memory. So, what is in my memory? I boot up my machine. What's the first thing in the memory? Operating system. Correct. So, the operating system is in memory. Okay. So, whether you're running Windows, Mac OS, Unix, the operating system is in memory. So, let's say all of this is 128 gigs. So, let's say this is going to bring it up to like 25 gigs. So, this 25 gigs is my operating systems. What else? My machine starts up. The operating system is loaded. Of the 128, 25 gig is just used by the operating system. Now what? What else is in memory? With this computer that we're using right now. The database software? Right. I have to load in, start up MySQL. Okay. So, then MySQL is also going to be in memory. It's a fairly complex, relational database management system. It has... So, this is my MySQL, my relational database management system. Okay. What else is in memory? Remember, memory contains every program, every application that you're executing. So, I have the operating system. Let's say Windows or Mac. I have MySQL, my database. What else is in memory? ... ... ... Does caches... Is cache in it? What's cache? What's cache? Um... It's used during RAM to make it faster. Okay. How does it make it faster? By storing the data RAM. Okay. So, let's talk about cache in a little bit. We also have our editor. Our SQL ... MySQL Workbench. That's another application that takes up memory. Let's say that I start loading data. ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... .. ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... .... ... ... ... ... ... ... ... ... ... ... ... .... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... . . . . . . . . .. ... ... ... ... ... ... ... ... .. ... ... ... ... ... .. ... ... ... ... .. ... What happens? I know it happens I lost data. ... ... ... ... ... Correct. ... ... ... ... If we have a failure after step six meaning my dirty block never got written ... to my storage device. That's a risk. How do I solve this problem? ... ... ... Remember this is like one computer that we're running. Computer only has like one memory in it. Power goes off to this computer How do we, you know, make sure that this data is like recovered? What are some ideas that you have? ... ... ... ... ... ... Can we use another block to back up the process? Okay, so you're saying you make a change to block number one and block number one contains 4050 so you're going to make another block the block number 100 block number 100 is a copy of that block? Yeah. Okay, where does this block reside? ... On the main memory. Right. So if both blocks exist in main memory and if the power goes off won't I lose both blocks? ... ... How about have the block 100 somewhere else? Where? So I have storage memory and processor. That's my computer. Storage, memory, processor. Where else do you want to put the block? In storage. Okay, I thought I already had the block in storage. It's like block number one. The block number one is my original block. Block number one in database block is my dirty block. So this is what we just did here. This arrow right here was to copy. Step number seven was to copy the dirty block from memory in my storage device. But the failure happened before we did number seven. The dirty block never got written to storage. Can we use the transaction logs from when the failure occurred? Can we use the transaction logs? So give me an example of what's going to be in the transaction log. The transaction name, the table, ... like the ID, the table, the column, and the attribute. Okay. So who is performing? Let's fill out this transaction log. Who is performing this transaction? Let's say you're connected in SQL Workbench. You're connected. So let's say you're in transaction number 100. What table are you trying to access? Accounts. And which column? Columns. And what is the actual SQL that you're going to be doing? What's the reason for your transaction log? Why do you want to have this? To do what? To record any changes made before it's saved. So once you record all these changes, what's the reason for saving it? Why do you want to save all the operations that you did? What can you do with it later? In case there's a failure to recover the data. Okay. You want to roll here. Keep going here. So this was the SQL. So that was done. So this entry. Okay. And we should probably also keep track of when this was done, the date of the transaction. So this was done on 11 8 202 3 at 2053. Okay. So that was done. The power goes off. So then how can I use this transaction log? You would look at the date and the time that the failure occurred and then perform the SQL. Right. You want to roll forward and re-execute what was done here. How do I know exactly what to re-execute? Where is that listed here? What am I re-executing? SQL. Right. I'm re-executing this. Okay. So this is our transaction log. I like this transaction log. When do you put an entry in the transaction log? With all these steps that are done, when do you do that? Which like step, which operation triggers the writing of the entry in the transaction log? Whatever changes like insert, update, delete. Okay. But when you say insert, update, delete, which operation triggers the writing of the insert, update, delete, you know, you didn't really like finish the operation. This is just the beginning of the operation. What do you have to tell the system to say I'm done? Commit. Correct. Or say what? You don't have to say commit. You don't have to say commit. You could also do what? Rollback. You could say rollback. Okay. Okay. So only when you say commit, that you affirmatively saying this will be saved, then I can roll the transaction log. Okay. So that's when. Now I'm going to ask you where. Where do you want to save this transaction log? We know what's being saved. We know when it's being saved. So now where? Where are you going to put this transaction log? This is your computer. You have storage. You have memory. You have processor. Pick one. Well, let me ask it in reverse. We had a failure. Where don't you want this to be? In memory. Right. You don't want the transaction log in memory because what good is it in memory if the power is off? I can't re-execute something if I don't save it. So you don't want to put it in memory. Do you want to put this into the processor? CPU? No. No, because CPU, it doesn't store. It does calculations. So you can't put it into the processor. What's left? Storage. Okay, so the storage. Remember, we have our blocks, but these blocks are reserved for my database tables. This is not a database table. This is just a file. This is a complex data structure. When you have a table, you have columns, you have primary keys, you have security, you have constraints, borrowing keys. This is a complex data structure. This looks to me like what? It's like Excel. I have columns. I have a couple and I have a row for each committed transaction. So it's a file. Okay. So let's say that we have a storage device and you save this to storage device. So we have a storage device and as you know, storage devices contain files. There you go. Okay. So now update these steps to include the creation of this transaction log. Where do you want to perform this? At what step? Maybe after step five. Okay. Why step five? Because we calculated it. Okay. But this step right here, that's what does the calculation. So what I'm highlighting now, this is step number six. But we said before, this is the only write to my transaction log after what is done. Commit or rollback. Right. Well, if I do a rollback, am I really writing anything in the transaction log? No. No. So I just wrote that there. So only after a commit. So I need a step here. Where do you want to put the committed? Or say we just say, keep it simple. Let's say the user said after doing the update, the user said, commit. Okay. So step number seven, user enters commit. Then step number eight will be create a rollback. You know, create row in transaction log. Okay. Then finally, we have to copy this dirty block over. Okay. Oh, good. So now we have this transaction log saved to this disk or another disk, but it's a file. This is a pretty quick save, the transaction log, because it's a simple row to a simple file. Okay. What's the performance impact for doing all this? What's the slowest part of this operation? Look at this whole, all the steps. Which part takes the longest? Which part takes the longest? Is it the storage device? Okay. So how long does it take to read data from my storage device and bring it into memory? What's the read-write time of reading data from a magnetic storage device? So step number three here. Again, you buy a storage device. This is like basic computer stuff. How long does it take to read a block of data from my storage device into memory? What's my unit? Minutes? Hours? Seconds? Or what? Isn't it like 10 to 12 milliseconds? Yes, it is. So 10 to 12 milliseconds to read a block from a magnetic storage device and bring it to memory. That's milliseconds. Thousandths of a second. Then over here, copy block one from database block bar to CPU. How quickly can I move data from memory to CPU? Pulling a block in and out of memory is how quick? Hours? Minutes? Seconds? What? Nanoseconds. Give that man a cigar. So it's about, let's say, 20 to 30 nanoseconds. How fast is a nanosecond? A millionth of a second. Billionth of a second. So it's like that. So billionth of a second. So of these two operations, reading data from disk in 10 to 12 milliseconds while copying data from memory to the CPU, nanoseconds, which one is slower? MS. Right, milliseconds slower. Thank you for getting that right. And then I have to copy the dirty block from database block bar first to my storage device so this is going to be another 10 to 12 milliseconds copying the data I'm writing to my storage device. So then doing the calculation, this is all within the processor. This is nanoseconds. This is very quick. So of all these steps, which is the slowest which is the slowest steps here? 3 and 9. Correct. So this is slow. And this is slow. So how often are we writing blocks from database block buffers to my to my storage device? How frequently do you want to do this? A lot. Okay. Give me something a little bit more technical rather than saying a lot. How frequently do you want to take the dirty blocks that are in database block buffers and write them out to the disk? How often do you want to do it? And whenever we want to update something? Well, whenever you do a commit. Okay. So what would be the performance impact if you were to write this out this dirty block immediately immediately after you say commit? Let's say that this is for a bank. Let's say it's during a lunch hour. People go to the bank. They make deposits. They make withdrawals. So there's like, you know, millions and millions of transactions that are occurring at a bank during lunch hour. So after every one of these transactions, there's going to be a commit to get depositing which are in money, and that's going to incur a read-write of 10-12 milliseconds. How's that going to impact the database performance from doing millions and millions of reads and writes? Well, does it make it faster? Does it make it slower? Or does it have no impact at all? There's only three answers. It makes it slower. Makes it slower. Okay. So that's not your objective. Your objective is not to make things slower. So how do you solve that problem? If you have these commits occurring immediately, if you have the transaction log being written, if you have the block being copied from database block to the storage device, immediately after the commit, that's going to incur another 12 milliseconds. But if all these millions and millions of transactions all happen, the system will just be consumed with reading and writing data from the disk. And the computer won't have any other, you know, CPU cycles to do anything else. So solve that problem. We can't, you know, write this data because the storage device can't keep up with it. It's not fast enough. I mean, clearly, if you're working at home, you're the only person on the computer and you do an update and you say commit, oh yes, that's not a problem. I'm talking about millions and millions of dirty blocks that have to be written because millions of people do the positive withdrawals. Sorry, I interrupted you. I can't copy my dirty blocks immediately because it slows down my storage device. We could use cache to speed things up. What is cache? It's like it's in the RAM and takes the process and basically remembers the whole process. Okay, so everything that we just did in the past hour, which part of all this is a cache? C-A-C-H-E. I can't do a calculation on storage. I can only do it like in memory. So cache is to bring in data into memory. That's what cache is. Which step here is my cache? Excuse me? Is it step three? Right. So this right here, this is my database cache. Database block buffers is taking the blocks off my slow storage device, which is milliseconds, and bring it into fast memory so that I can do calculations. So this is a in a way acting as a cache. Okay. Let's do another calculation. So this one was, I did this operation. So then, how can I make this go faster? I'm giving you no money, so don't tell me we'll buy a faster computer. Okay. So how can I make these steps go faster? And when somebody asks you a question, make something go faster, first thing you should analyze is, well, what's the slow part of the operation? If I can get rid of the slow parts, or minimize the slow part, or increase the speed of the slow part, you know, that's going to speed things up. So how can I make performing this update, which involves all these nine steps, make it faster? That's going to be the question you're going to be asked for the rest of your life for everything you do. Make it faster, make it smaller, and make it cheaper. If you can't do that, then I'm going to ask somebody else who can do it. And the person who gives me the answer, that's the person who I give the job to. Make it go faster. What if you, I mean, this might sound crude, but what if you just entered commit less frequently? If you had to do multiple updates, you just use commit at the very last minute? Okay, so you're saying that rather than commit immediately after doing the update, I commit after how many updates? Remember, each update represents in banking, this is a $50 deposit. So you went to the bank, Citibank, and you deposited $50. So this is your transaction. So when do you want to do a commit on your transaction of your deposit? As soon as possible. As soon as possible. Okay, so if it's your money, you want to do a commit really fast. But if it's somebody else's money, you can wait two hours, right? Okay, that's a great fact. I like that. I do agree. Doing less commits will certainly make it faster so you improve the speed. But what else did you impact? Reliability. Reliability. So now if you do less commits, okay, that's your choice. But now you have all these blocks, you know, hanging out in memory that are not being copied out to the storage device. Oh, you solved the speed issue but now you have more risk and more blocks in memory. Okay. If the power goes off, then nothing would have been saved. So you solve one problem, of course another problem. Make this go faster. And you can use, you know, another concept in computer science. You know, operating systems, telecommunications. What's the slow part? How do you make it go faster? Somebody just said it ten minutes ago. ... ... ... ... ... That's why this database class is towards the end of your computer science curriculum because it's really testing to integrate a lot of the different concepts that you had in other classes. The database is used, uses networking, operating systems, storage device, and sorting. It's all connected. So this is really, you know, putting your skill set to the test here. Make this go faster. Copying is slow, so we could use cache on that part. Use cache on that part? What does that mean? So, like, make the copying more faster. How do I make the copying go faster? Remember, am I giving you money? You can't buy a faster storage device and say, look, I made it faster because I just bought a faster storage device. Sometimes you have money. Sometimes you don't. Can you just keep the blocks in main memory? Okay. So what's the size of my storage device? Four terabytes. Four terabytes. What was the size of memory? 128 gigs. So which is larger? The storage device. Storage device. So if you were to purchase, so four terabytes of storage, it's about like, let's say it's a high-end for a server, you know, let's call it, like, you know, $1,000. This is not something you would buy in Best Buy, but let's say it's a high-end. $1,000 for 1,000 terabytes. 128 gigs. If you were to go, like, to the Apple site and build yourself, like, your own computer, and you were to keep adding in more memory, memory is expensive as compared to storage. So it will probably cost something like, you know, like $50,000 to get, like, four terabytes of memory. Like, you know, that's a lot. And this is, like, cheap memory. So if you were to get a four terabyte of memory, once you had four terabytes of memory, then what? What would you do with it? You could keep the entire database in memory, so it would speed up the read and write. Right. If you had four terabytes of memory, assuming you had that much money, you could take every block that's on your storage device that takes you 10 to 12 milliseconds to read, copy all those blocks into memory, and you better make sure you have a good nuclear power source to keep that power running on the computer. That would be the most awesome computer in the entire world because how quickly would you be able to retrieve a block? Nanoseconds. Correct. That would be totally awesome. But what would the cost be? It would be very expensive in order to do all that. Okay. So it's a little balanced. And also what's the risk if you bring all your blocks into memory? You have another issue now. It's volatile, so higher risk of data loss. Right. If somebody trips over the power plug and unplugs it from the wall, you're not going to just lose what's in your database. Block buffers, you're going to lose the whole database. So it's like... I do agree this would be a great computer. Okay. So how can I make this go faster? I think you're on the right track here. Basically, you kind of like eliminated this millisecond read and writes. So what process do you know without spending any money by just modifying these steps I can make this go faster? Step number three. I'm copying the block from my storage device into memory. How can I make this more efficient? Oh, why is it in... Why is the data in the storage device for step number three? I don't know. You tell me because that's where my block is. Where do you want the block to be? In the storage device. Right. So that's what I'm doing here. So I'm copying block number one from my storage device to bring it into database block buffers. Do we have to bring it into main memory Where else can you put it? Where else can you put it? I guess on another place maybe? Well, in current technology, I have storage, I have memory, I have processor. That's it. Nothing else has been invented yet. I don't know where else to put it. I don't know where else to put it. But make this go faster. I'm immediately always copying the block B1 from storage device into memory. Why do I have to always copy it? Make this a smart copy. Where else can this block exist? Does the block number one always have to be on my storage device? Where else can it be? The main memory. Right. As of right now, where is block number one? On storage. And where is the main memory? On storage. And it's where? Main memory. Well, it's in database block buffers. It's in two places. So modify this read. Rather than always read block one, block number one from storage device, modify this a little bit. What is, you used the word database cache. So do that. What is a database cache? Don't just say it. Tell me what it actually does. Contains the most recently used blocks. Yes. So how could I use that to increase performance? If the block was already in memory, there's no reason to copy it again. Ah. Give me the if statement. I love this statement. Give me an if statement. If it's step number three, don't automatically read block number one from storage device's memory. Give me an if statement. If what? If the block is not in main memory. If block number one is not in database block buffers, then? Then I think the rest of the code is okay. Okay. So then what's my else part? Else just read from database block buffers. Ah. Else read block one from database block buffers. So if you were to execute another update command and it was similar to this, one, one, one, one, one, one, and this, so execute step number three. The code that you created, get this to work, you'd be very rich. So block number one, where does it exist right now? In main memory. Database and storage device. Okay. So it's in both places. And they both have 4050 4050 because I did a commit. Okay. So execute your new step number three with the if statement. If block number one is not in database block buffers, then copy block to memory. Is that first part true or false? False because it is in the database block buffer. It is. If block number one is not in database block buffers. Okay. So this is like the first part is false. So then you get to do what part then? Read directly from the database block buffer. How quick is that read? Nanoseconds. Ah. But before it was how much? 10 to 12 milliseconds. Ah. So you increase the speed, so you eliminate it. You eliminated this step by doing a simple if statement. Why read something? I'm just saying what you said in a different way. Why read the block off my disk, storage device if it already exists in my database block buffers? And your if statement is very creative. It said, you know, check. Before you automatically read from storage device, check memory. If it's there, read it from there. Oh. That's 20 nanoseconds. So this increases your rewrites like a lot. So this is a cache. Okay. What you just invented here. If you invented it like 30 years ago, it would have been, you know, better. Okay. So I'm a little bit in overtime here. There was a request. We still have some more to solve on this. There was a request on request on third normal form. Again, this is also in the textbook. But the third normal form is the concept of you're in first normal form, you're in second normal form. Third normal form does one more check. It checks to make sure that there's no transitivity. What is transitivity? We want to make sure this does not exist. What is transitivity? I'm just pulling this from another class. What's transitivity? Is it a relation between three things? Okay. Three things. What is it by three things? So it's functionally dependent. So if I have let's say I have three attributes, A, B, three columns, A, B, and C. So let's say that I say A. So B is functionally dependent upon A. And then what comes next, the transitivity? C is functionally dependent. Sorry. So C, what is it? I would say B is functionally dependent on C. So B So it's what here? So B is functionally dependent on C. And what's my third line? And what's my third line? Through transitivity, what will be true? A is functionally dependent on C. I'm a little confused. The white on the left of the arrow is functionally dependent on what's on the right. The first line is B is functionally dependent upon A. Next line is C is functionally dependent upon B. I'm just making those two statements. And then line three, through transitivity, C will be functionally dependent upon A through B. So this is a transitive relationship. Third normal form says that you don't want this to happen. You have to do a test to make sure in any table this scenario doesn't happen. That's it. That's what third normal form is. And A, B, and C are just columns, and you want to make sure that you don't have this relationship. Okay? So let's say that you have student ID, student first, student last, and then let's say that you have the course in which the person registers for. So this would be the course, and this would be the instructor. So in this example, so the F is functionally dependent upon the course. For each course, there exists one and only one staff. That's true. But also I have this also relationship where I have student ID, student first. Student first is functionally dependent upon student ID. For each occurrence of student ID, there is a student first. But also I could, you know, say that that course is functionally dependent upon student because the student is registered for that course. Now I have this relationship where, you know, there's a relationship between staff and course and course and student where staff is functionally dependent upon student. Okay. So this is my transitive relationship. If this occurs in my table, you want to prevent that from happening. That's all third normal form is. You want to do a test to make sure that this doesn't happen. How do I prevent it from happening? In second normal form, how do I, you know, prevent there being a violation in second normal form? We created multiple tables and used foreign keys? Yeah. Another way of saying would be another way of saying it, remove the column that's causing the transitivity. So like remove course and remove staff. Get rid of the column that's causing this transitive relationship. So third normal form is just another test. I agree it doesn't happen that often, but, you know, you still have to test for it. There's something like 10 different normal forms. We did three. Okay. So just to repeat it, A, B, and C are columns. You want to make sure this scenario doesn't happen. Like here's an example. I would say at this point, the textbook has, you know, another explanation in a narrative, and it has a few more examples. This is just something you just have to study and just do a few examples to see it. But just think of it as in your toolbox of doing tests on your tables, this is just one more test to make sure your table is normalized. Don't get all hung up about it. Just, you know, do a read about it, do a couple of examples, and then just add it to your list of checks that you do. Okay. So I'll stick around if people have questions about the project. And I know I still owe people some project ones, but I'm almost done. Let me stop the recording.
