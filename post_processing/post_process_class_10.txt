Here is the text file with useless conversation removed, while preserving the important content, examples, and context:

<documents> <document index="1"> <source>paste.txt</source> <document_content> Okay, can everybody see the slide that says Relational Algebra? Yes. Yes. Great. Okay, let's get started. The objective for today is to get back to normalization. I just want to begin the discussion about the topic Relational Algebra. Relational Algebra is the mathematical language which underlies the SQL that you're doing. For example, when you do searches, when you do joins, when you have tables, when you have columns, there's a mathematical language called Relational Algebra, along with Relational Calculus, which allows you to specify the process of joining and how that impacts speed. So we're going to touch upon that. There's going to be a lot of parallels to what you saw in SQL, which is the hands-on. Now we're just discussing some of the underlying theory behind it. And Relational Algebra allows us to also perform searches and also to organize our data. So we're going to be discussing some terminology today. And so it's going to take a couple of classes to discuss Relational Algebra, Relational Calculus, and we'll do this on and off in the next couple of weeks.
So Relational Algebra, just to be clear, is a mathematical language. There is no software that you use, unlike SQL, which is hands-on. You can log on, you can type it, you can compile it, you can get errors, or it executes. Relational Algebra is like pencil, paper. So let's get started. We'll do some terminology here. So Relational Algebra organizes into several different types of operations that we can perform, and they should all be similar. You can do a selection, projection, Cartesian product, union, or set difference. There are many others, like functions, for example.

So the selection operation sounds like what in SQL? Select. So Cartesian product, which is the process of joining two relations, two objects, sounds like what in SQL? How do we join? Join. We have join, but the way we discussed it in class was that if I have two tables, what's the process of connecting the two tables? Select from then what? Where the primary key in one table is equal to the foreign key in another table. So that's a Cartesian product.

So let's do some terminology. We're going to keep recycling this terminology, but just laying the foundation for this. So what we used to call a table in SQL is called a relation in Relational Algebra. And so we have the table, like over here, and then with the relation. So within the relation, we have many columns. In SQL, it's called a column. In Relational Algebra, it's called attributes. So an attribute called branch number, attribute branch street, attribute city, attribute called postal code. Within the whole relation, it's called, you know, this is all one relation called branch. The relation at the bottom here, this is a relation called staff. So the relation called branch has four attributes, branch, street, city, postal code. And each row in the relation is called a tuple, T-U-P-L-E. So just changing some terminology. And the primary key, let's say it's branch number, that's still the case. And the terminology foreign key, notice how we have one row for each branch number and branch. And then when we keep track of the staff, we want to say, well, which branch does each staff assigned? Notice how we have branch number next to the staff over here. But the domain of branch number is only those values with the primary key branch number and branch. Okay, so that's still the same. Okay, and some other terminology, the degree is a number of attributes. So the degree is four for branch. And the cardinality is a number of tuples. So in branch, it's five. One, two, three, four, five. So cardinality is the number of rows, the degree is the number of attributes.

Okay, so let's say that here I have one relation. So how many attributes do I have in this relation? Six. Right, so I have title, rating, genre, director, data release, actor. So I have six attributes. And I have a total of one, two, three, four, five tuples, five rows. Okay, so let's say that I wanted to do a search. Find all movies that have a rating of PG-13. So I have to create a query where the attribute rating is equal to PG-13. This should sound familiar as what you had to do in SQL. So that's the concept of a selection in relational algebra. Okay, so selection, key takeaway is the selection is eliminating the rows.

Okay, relational algebra does certain things. One of them is selection. Another thing that you can do in relational algebra is a projection. Projection is a process of how do you limit your attributes. I'm not interested in all my attributes. I only want to see some attributes. So in SQL, what's the equivalent of displaying only some attributes? I'm using a select statement, but basically picking certain columns over others. Correct. So in relational algebra, you'll say select title, comma, rating, comma, actors from my table. As compared to saying select star. You know, I'm used to just saying select star just as a matter of convenience. But if I wanted to limit my attributes or projection, I would say select and then what are the column names.

Okay, let's review Cartesian product. And you may remember this from your, like, discrete mathematics class. So let's say that I have a relation called P. And P has two tuples. Tuple A, tuple B. Let's say I have another relation called Q. And Q has, you know, three tuples. Tuple 1, tuple 2, tuple 3. Okay. So P, Cartesian product Q, which is a join, means I'm taking every row in P and joining it to every row in Q. And then repeat that. So A is going to be joined to 1. I'm just going to draw here. So A is going to be joined to 1. A is going to be joined to 2. A is going to be joined to 3. So that's where we get A1, A2, A3. And then we're going to say B is going to be joined to 1, B joined to 2, B joined to 3. So all possible permutations. B1, B2, B3. So when we say P, Cartesian product Q, that's taking every tuple in P, joining it to every tuple in Q. So the equivalent in SQL is, you know, select from table, comma, table, comma, table. You join multiple tables together. And this is necessary if you have to answer a question. But you need attributes from more than one relation.

So let's do some syntax. Like what commands do we actually have to enter? What's the terminology in relation algebra? So we have two commands. One is the selection. So over here. So this is my selection. And we use this select symbol. Okay. And then we're saying, this select, from which relation do you want to do the search on? And then the predicate is, what is the search? Rating equal PG. So what is your expression? That evaluates to true or false for each tuple. Then you also have another symbol. So this is projection. I want to limit my attributes. Then from which relation? Relation called R. Replace R with the name of the relation. And then you list all the attributes you want to display. So attribute 1, attribute 2, attribute 3, et cetera.

Okay, let's do a quick example. Okay. So we're going to do some examples to illustrate this together. And then we're going to go, you know, hands-on. We're going to pencil and paper. We're going to design a database using relational algebra. Okay. So now let's do some examples. So we have a relation called customers, another relation called stores. So customers has how many tuples? Three. Right. So we have three tuples. And customers also has three attributes. So attribute, attribute, attribute. And this is my primary key. Okay. So one tuple for each customer. We also have a relation called store. My primary key, store street, store city, store zip. Okay. And the rules are, you know, try not to give – don't give spaces to your attribute names. And your attribute should be descriptive. Okay. So don't call the attribute XYZ. Call it, you know, city, state, zip. Make it – anybody who looks at it will understand. Okay. So I have two relations.

Okay. I have two more relations, a relation called, you know, animals and a relation called purchases. Okay. So now we have these four relations, but they're, you know, they're – have similar attributes. Okay. So let's go back here. So I have customer, customer first, customer last. And relations


Here is the rest of the document with useless conversation removed:

to store is what is information about the store. Store, street, city, zip. Then I have the animals. So this is like a pet store that I'm designing here. Okay. So in my pet store, we also have to keep track of the animals. You know, each animal – so we have to keep track of the species of the animal. We also have to gender and some type of number, whether it's an aggressive animal or not aggressive animal. And a pet store also sells, you know, animals and also sells, like, accessories, you know, like fish balls and fish food. So we have something called a product type to keep track of what is the product. And finally, we have purchases, which is last. Why is the purchases, like, my last relation? What's, like, special about my attributes here? Don't they draw from other tables? So customer ID is what type of attribute? It's a foreign key. So customer ID is a foreign key. And it's limited. My domain is I can only pick a value 100 if 100 exists as a primary key in the customer relation. And 407 has to exist in the customer relation. That ensures you of maintaining data integrity. And so this is a foreign key, which is why this relation is less, because I had to first create the customer relation before I made it as a foreign key here. Have an animal ID. Animal ID is what type of attribute? Foreign key. And store ID. Store ID is what type of attribute? Also a foreign key.

Okay. Let's answer some questions now.

Question one: Identify all customers. Display the customer name.
From which relations am I searching? Customers. And within the customer's relation, which attribute do I need? Last name. Do I have to use a Cartesian product? No, because it's just one relation. Am I limiting my customers? False, I'm not limiting. I want all customers. So there is no selection. But I only want to display the customer name, not all attributes. So projection limits my attributes:
projection
from customer
customer last

Question two: Identify customers who viewed an action show on 10-1-2023. Display the customer name and show title.
You have customers, shows, and views relations. First join customers and views, removing disjoint rows where customers.email = views.email. Send to relation A.
Then join A with shows, removing disjoint rows where A.showID = shows.showID. Send to B.
Further limit B by selecting only tuples where viewDate = '10-1-2023' AND genre = 'action'. Send to C.
Finally, project from C to display:
customer first, customer last, show title

Let's design a Netflix database with relations for customers, actors, shows, and views.

(Database design shown)

Give me a question that will involve two relations.
Identify all customers who watched an action show. Display customer name and show title.

(Full relational algebra solution shown step-by-step to answer this query)

So we're fleshing out and building our language of relational algebra, and we're going to be able to do all types of queries like find all shows by a genre, count shows, highest/lowest rated shows, etc. All backed by this underlying mathematical theory behind SQL.

</document_content>
</document>
</documents>